[
  {
    "id": 1,
    "question": "Entity Framework est principalement :",
    "options": [
      "Un langage de base de données",
      "Un ORM (Object-Relational Mapper)",
      "Un framework de logging",
      "Une extension de LINQ",
      "Une bibliothèque pour Blazor"
    ],
    "correctAnswer": 1,
    "part": 1
  },
  {
    "id": 2,
    "question": "L’approche Code-First consiste à :",
    "options": [
      "Créer d’abord la base de données et générer le code ensuite",
      "Créer les classes C# avant la base de données",
      "Utiliser un diagramme EDMX",
      "Créer un script SQL avant les entités",
      "Éviter les migrations"
    ],
    "correctAnswer": 1,
    "part": 1
  },
  {
    "id": 3,
    "question": "Quelle classe représente une session avec la base de données dans EF Core ?",
    "options": [
      "DbSet",
      "DbConnection",
      "DbContext",
      "DatabaseContext",
      "ContextService"
    ],
    "correctAnswer": 2,
    "part": 1
  },
  {
    "id": 4,
    "question": "Un DbSet<Student> représente :",
    "options": [
      "Une collection d’entités Student mappée à une table",
      "Une seule instance de Student",
      "Un script SQL de migration",
      "Une clé étrangère",
      "Un logger d’exécution"
    ],
    "correctAnswer": 0,
    "part": 1
  },
  {
    "id": 5,
    "question": "Par défaut, EF Core suit les changements sur les entités grâce à :",
    "options": [
      "L’API LINQ",
      "Le Change Tracker",
      "Le Migration Builder",
      "Le Mapperly",
      "L’EntityStateManager"
    ],
    "correctAnswer": 1,
    "part": 1
  },
  {
    "id": 6,
    "question": "Dans EF Core, quelle méthode enregistre les modifications dans la base ?",
    "options": [
      "context.Submit()",
      "context.SaveChangeAsync()",
      "context.SaveChanges()",
      "context.Persist()",
      "context.Commit()"
    ],
    "correctAnswer": 2,
    "part": 1
  },
  {
    "id": 7,
    "question": "Les propriétés d’une entité mappées à des colonnes simples sont appelées :",
    "options": [
      "Propriétés scalaires",
      "Propriétés de navigation",
      "Propriétés virtuelles",
      "Propriétés abstraites",
      "Propriétés persistées"
    ],
    "correctAnswer": 0,
    "part": 1
  },
  {
    "id": 8,
    "question": "Le code suivant illustre une relation : public class Student { public Grade Grade { get; set; } } Quel type de relation ?",
    "options": [
      "One-to-Many",
      "One-to-One",
      "Many-to-Many",
      "Aucun lien",
      "Un lien nullable sans clé"
    ],
    "correctAnswer": 0,
    "part": 1
  },
  {
    "id": 9,
    "question": "L’attribut [Key] en EF Core :",
    "options": [
      "Supprime la clé primaire",
      "Indique la propriété servant de clé primaire",
      "Configure un index",
      "Marque la propriété comme obligatoire",
      "Spécifie la taille maximale"
    ],
    "correctAnswer": 1,
    "part": 1
  },
  {
    "id": 10,
    "question": "Comment rendre une propriété non mappée en base de données ? Quelles approches permettent d'exclure une propriété du mapping en base de données ?",
    "options": [
      "[NotMapped]",
      "modelBuilder.Entity<Student>().Ignore(s => s.FullName)",
      "[Ignore]",
      "modelBuilder.Entity<Student>().Property(s => s.FullName).HasColumnName(null)",
      "[DatabaseGenerated(DatabaseGeneratedOption.None)]"
    ],
    "correctAnswer": 0,
    "part": 1
  },
  {
    "id": 11,
    "question": "La méthode OnModelCreating d’un DbContext est utilisée pour :",
    "options": [
      "Configurer la connexion à SQL Server",
      "Configurer les entités via Fluent API",
      "Enregistrer les données",
      "Supprimer la base de données",
      "Charger les entités"
    ],
    "correctAnswer": 1,
    "part": 1
  },
  {
    "id": 12,
    "question": "Dans la configuration Fluent API, quel code configure la table ? modelBuilder.Entity<Student>().ToTable(\"StudentInfo\");",
    "options": [
      "Déclare une entité",
      "Mappe l’entité à une table SQL spécifique",
      "Ajoute l’entité",
      "Configure une relation",
      "Configure une table"
    ],
    "correctAnswer": 1,
    "part": 1
  },
  {
    "id": 13,
    "question": "Pour configurer une colonne auto-incrémentée avec FluentApi, quelle(s) approche(s) est/sont valide(s) ?",
    "options": [
      "[DatabaseGenerated(DatabaseGeneratedOption.Identity)]",
      "modelBuilder.Entity<User>().Property(u => u.Id).ValueGeneratedOnAdd()",
      "[Key] suffit pour un int/long",
      "modelBuilder.Entity<User>().Property(u => u.Id).UseIdentityColumn()",
      "modelBuilder.Entity<User>().Key(u => u.Id).UseIdentityColumn()"
    ],
    "correctAnswer": 1,
    "part": 1
  },
  {
    "id": 14,
    "question": "Dans EF Core, Include() est utilisé pour :",
    "options": [
      "Charger les entités avec lazy loading",
      "Charger explicitement les entités liées (eager loading)",
      "Supprimer une relation",
      "Ajouter une migration",
      "Mapper une clé étrangère"
    ],
    "correctAnswer": 1,
    "part": 1
  },
  {
    "id": 15,
    "question": "Le code suivant : context.Students.Remove(student); context.SaveChanges(); fait quoi ?",
    "options": [
      "Modifie la ligne",
      "Supprime la ligne correspondante en base",
      "Détache l’entité du contexte",
      "Ajoute un étudiant",
      "Vide la table"
    ],
    "correctAnswer": 1,
    "part": 1
  },
  {
    "id": 16,
    "question": "Le ChangeTracker gère les états suivants, sauf :",
    "options": [
      "Added",
      "Modified",
      "Deleted",
      "Created",
      "Unchanged"
    ],
    "correctAnswer": 3,
    "part": 1
  },
  {
    "id": 17,
    "question": "Pour une relation Many-to-Many, EF Core 9 recommande :",
    "options": [
      "Créer manuellement les clés étrangères",
      "Utiliser .UsingEntity<Jointure>() dans Fluent API",
      "Utiliser [ManyToMany]",
      "Créer une seule propriété virtuelle",
      "Mapper les deux côtés sans jointure"
    ],
    "correctAnswer": 4,
    "part": 1
  },
  {
    "id": 18,
    "question": "La suppression en cascade (Cascade Delete) :",
    "options": [
      "Supprime toutes les tables",
      "Supprime les enfants quand le parent est supprimé",
      "Empêche la suppression",
      "Efface la base de données entière",
      "Nécessite WillCascadeOnDelete(false) pour l’activer"
    ],
    "correctAnswer": 1,
    "part": 1
  },
  {
    "id": 19,
    "question": "Pour désactiver la suppression en cascade dans Fluent API : .OnDelete(DeleteBehavior.Restrict);",
    "options": [
      "Active le delete",
      "Ignore les relations",
      "Empêche la suppression du parent s’il a des enfants",
      "Supprime les enfants",
      "Clone la relation"
    ],
    "correctAnswer": 2,
    "part": 1
  },
  {
    "id": 20,
    "question": "Une migration EF Core sert à :",
    "options": [
      "Générer des seeders",
      "Créer ou modifier le schéma de base de données",
      "Supprimer les entités",
      "Synchroniser le modèle et la base de données",
      "Synchroniser la base de données et le modèle"
    ],
    "correctAnswer": 1,
    "part": 1
  },
  {
    "id": 21,
    "question": "Commande pour créer une migration via CLI :",
    "options": [
      "dotnet ef add",
      "dotnet ef create migration",
      "dotnet ef migrations add NomMigration",
      "add-migration",
      "update-database"
    ],
    "correctAnswer": 2,
    "part": 1
  },
  {
    "id": 22,
    "question": "Commande pour appliquer une migration :",
    "options": [
      "dotnet ef database update",
      "dotnet ef run migration",
      "add-migration",
      "update-database",
      "context.apply()"
    ],
    "correctAnswer": 0,
    "part": 1
  },
  {
    "id": 23,
    "question": "context.Database.EnsureCreated() :",
    "options": [
      "Met à jour la DB",
      "Crée la base sans gestion de migration",
      "Supprime la base",
      "Crée une migration automatique",
      "Installe EF Core"
    ],
    "correctAnswer": 1,
    "part": 1
  },
  {
    "id": 24,
    "question": "Dans EF Core, ExecuteUpdateAsync :",
    "options": [
      "Met à jour plusieurs lignes directement en SQL",
      "Supprime plusieurs lignes",
      "Ajoute un ensemble d’entités",
      "Met à jour une seule entité",
      "N’existe pas"
    ],
    "correctAnswer": 0,
    "part": 1
  },
  {
    "id": 25,
    "question": "Le Scaffold-DbContext sert à :",
    "options": [
      "Générer le modèle à partir d’un schéma existant",
      "Supprimer des migrations",
      "Ajouter des données par défaut",
      "Mettre à jour un modèle d’entité",
      "Mettre à jour un snapshot"
    ],
    "correctAnswer": 0,
    "part": 1
  },
  {
    "id": 26,
    "question": "Les fournisseurs EF Core permettent de :",
    "options": [
      "Gérer les relations entre entités",
      "Changer de moteur de base de données (SQL Server, PostgreSQL, etc.)",
      "Configurer les entités",
      "Créer des migrations",
      "Sérialiser les entités"
    ],
    "correctAnswer": 1,
    "part": 1
  },
  {
    "id": 27,
    "question": "Exemple de code pour requêter avec LINQ (Select new {...}). Résultat :",
    "options": [
      "Une liste d'objets anonymes avec Name, CourseCount et Courses, sans tracking, triée par nom",
      "Une exception car Select() après Include() ignore les données chargées par Include",
      "Un résultat identique même si on retire Include() et ThenInclude() car Select() charge automatiquement les relations nécessaires",
      "Une requête SQL avec LEFT JOIN sur Enrollments et Courses, puis une projection côté client",
      "Une exception car AsNoTracking() et Include() sont incompatibles"
    ],
    "correctAnswer": 0,
    "part": 1
  },
  {
    "id": 28,
    "question": "Le mot clé virtual sur une propriété de navigation permet :",
    "options": [
      "D’empêcher la sérialisation",
      "Le lazy loading",
      "Le mapping manuel",
      "Le changement d’état",
      "L’immuabilité"
    ],
    "correctAnswer": 1,
    "part": 1
  },
  {
    "id": 29,
    "question": "Quel namespace contient DbContext ?",
    "options": [
      "System.Data",
      "Microsoft.EntityFrameworkCore",
      "Microsoft.Data.SqlClient",
      "System.Linq",
      "EFCore.Context"
    ],
    "correctAnswer": 1,
    "part": 1
  },
  {
    "id": 30,
    "question": "Fluent API et Data Annotations :",
    "options": [
      "S’excluent mutuellement",
      "Peuvent être combinés, Fluent API a priorité",
      "Ne peuvent pas coexister",
      "Peuvent être combinés, Data Annotations a priorité",
      "Servent au seeding"
    ],
    "correctAnswer": 1,
    "part": 1
  },
  {
    "id": 31,
    "question": "Dans un DbContext, la méthode OnConfiguring :",
    "options": [
      "Configure la chaîne de connexion",
      "Configure les relations",
      "Gère les migrations",
      "Enregistre les logs",
      "Ajoute les seeds"
    ],
    "correctAnswer": 0,
    "part": 1
  },
  {
    "id": 32,
    "question": "L’état Detached d’une entité signifie :",
    "options": [
      "Non suivie par le contexte",
      "Supprimée de la base",
      "Ajoutée à la base",
      "Non persistée mais suivie",
      "Synonyme de Deleted"
    ],
    "correctAnswer": 0,
    "part": 1
  },
  {
    "id": 33,
    "question": "context.Entry(entity).State = EntityState.Modified;",
    "options": [
      "Force EF à marquer une entité comme modifiée",
      "Détache l’entité",
      "Supprime l’entité",
      "Ajoute la clé étrangère",
      "Sauvegarde l’entité"
    ],
    "correctAnswer": 0,
    "part": 1
  },
  {
    "id": 34,
    "question": "Pour injecter un DbContext dans ASP.NET Core :",
    "options": [
      "builder.Services.AddScoped<MyContext>()",
      "builder.Services.AddDbContext<MyContext>()",
      "builder.AddDb()",
      "services.UseSqlServer()",
      "builder.UseEFContext()"
    ],
    "correctAnswer": 1,
    "part": 1
  },
  {
    "id": 35,
    "question": "Les migrations EF Core sont stockées dans :",
    "options": [
      "bin/Debug",
      "Database/Migrations",
      "Le dossier Migrations du projet",
      "%appdata%",
      "Le fichier appsettings.json"
    ],
    "correctAnswer": 2,
    "part": 1
  },
  {
    "id": 36,
    "question": "Une Navigation Property de collection :",
    "options": [
      "Mappe une seule entité",
      "Représente une liste d’entités liées",
      "Est obligatoire",
      "Est One-To-Many",
      "Sert uniquement aux Many-to-Many"
    ],
    "correctAnswer": 1,
    "part": 1
  },
  {
    "id": 37,
    "question": "EF Core gère les transactions :",
    "options": [
      "Automatiquement sur SaveChanges()",
      "Uniquement manuellement",
      "Jamais",
      "Avec ctx.Database.BeginTransactionAsync & ctx.Database.Commit/Rollback",
      "Avec [Transactional]"
    ],
    "correctAnswer": 0,
    "part": 1
  },
  {
    "id": 38,
    "question": "L’instruction : context.Attach(entity);",
    "options": [
      "Attache une entité existante au contexte sans modification",
      "Attache une entité existante",
      "Ajoute une entité",
      "Ajoute une entité avec modification",
      "Ne suis pas l’entité dans le change tracker"
    ],
    "correctAnswer": 0,
    "part": 1
  },
  {
    "id": 39,
    "question": "IEntityTypeConfiguration<T> sert à :",
    "options": [
      "Configurer l’injection de dépendances",
      "Déplacer la configuration Fluent API dans une classe dédiée",
      "Configurer les entités",
      "Générer la DB",
      "Découple les configurations du DB contexte"
    ],
    "correctAnswer": 1,
    "part": 1
  },
  {
    "id": 40,
    "question": "modelBuilder.ApplyConfigurationsFromAssembly(...) :",
    "options": [
      "Applique les migrations",
      "Applique automatiquement toutes les configurations d’entités dans l’assembly",
      "Compile la base de données",
      "Sauvegarde les entités",
      "Crée un contexte"
    ],
    "correctAnswer": 1,
    "part": 1
  },
  {
    "id": 41,
    "question": "ASP.NET Core est :",
    "options": [
      "Un framework uniquement Windows",
      "Multiplateforme et open-source",
      "Basé sur IIS exclusivement",
      "Sans injection de dépendances",
      "Dédié à Blazor uniquement"
    ],
    "correctAnswer": 1,
    "part": 1
  },
  {
    "id": 42,
    "question": "Le point d’entrée d’une application API est :",
    "options": [
      "Startup.cs",
      "Program.cs",
      "MainController.cs",
      "AppConfig.cs",
      "ApiEntry.cs"
    ],
    "correctAnswer": 1,
    "part": 1
  },
  {
    "id": 43,
    "question": "Une API minimaliste :",
    "options": [
      "Nécessite ControllerBase",
      "Utilise app.MapGet(...) ou app.MapPost(...)",
      "app.Controllers.Get ou app.Controllers.Post",
      "Ne peut pas retourner JSON",
      "Nécessite MVC"
    ],
    "correctAnswer": 1,
    "part": 1
  },
  {
    "id": 44,
    "question": "Un contrôleur Web API hérite généralement de :",
    "options": [
      "Controller",
      "ControllerBase",
      "BaseController",
      "WebController",
      "MvcBase"
    ],
    "correctAnswer": 1,
    "part": 1
  },
  {
    "id": 45,
    "question": "Attribut pour une route GET :",
    "options": [
      "[HttpPost]",
      "[Route(\"GET\")]",
      "[HttpGet]",
      "[Verb(\"Get\")]",
      "[Get]"
    ],
    "correctAnswer": 2,
    "part": 1
  },
  {
    "id": 46,
    "question": "Méthode CreatedAtAction(...) retourne un code HTTP:",
    "options": [
      "201 Created",
      "200 OK",
      "404 NotFound",
      "204 NoContent",
      "400 BadRequest"
    ],
    "correctAnswer": 0,
    "part": 1
  },
  {
    "id": 47,
    "question": "ActionResult<T> combine :",
    "options": [
      "Une Action par défaut + Résultat",
      "Typage fort + flexibilité des statuts de réponse",
      "T + JSON",
      "Response only",
      "Middleware + Result"
    ],
    "correctAnswer": 1,
    "part": 1
  },
  {
    "id": 48,
    "question": "Le code suivant : return NotFound(); Renvoie :",
    "options": [
      "500",
      "200",
      "404",
      "201",
      "204"
    ],
    "correctAnswer": 2,
    "part": 1
  },
  {
    "id": 49,
    "question": "Le pipeline d’exécution ASP.NET Core est une chaîne de :",
    "options": [
      "Routes",
      "Middlewares",
      "Controllers",
      "Filtres uniquement",
      "Assemblies"
    ],
    "correctAnswer": 1,
    "part": 1
  },
  {
    "id": 50,
    "question": "builder.Services.AddControllers() :",
    "options": [
      "Active le routage basé sur les contrôleurs",
      "Enregistre les contrôleurs dans le conteneur DI",
      "Démarre la base de données",
      "Ajoute Swagger",
      "Crée la route API"
    ],
    "correctAnswer": 1,
    "part": 1
  },
  {
    "id": 51,
    "question": "app.MapControllers() :",
    "options": [
      "Active le routage basé sur les contrôleurs",
      "Enregistre les contrôleurs dans le conteneur DI",
      "Configure Open Api",
      "Active l’API",
      "Initialise Serilog"
    ],
    "correctAnswer": 0,
    "part": 1
  },
  {
    "id": 52,
    "question": "Dans appsettings.json, les chaînes de connexion se trouvent sous :",
    "options": [
      "DbContext",
      "EF",
      "ConnectionStrings",
      "ToDoConnectionStrings",
      "DatabaseConfig"
    ],
    "correctAnswer": 2,
    "part": 1
  },
  {
    "id": 53,
    "question": "L’attribut [ApiController] permet :",
    "options": [
      "D’activer Swagger",
      "La validation automatique des modèles et le binding intelligent",
      "Le routing par convention",
      "Le mapping JSON manuel",
      "L’injection de dépendance"
    ],
    "correctAnswer": 1,
    "part": 1
  },
  {
    "id": 54,
    "question": "Quelle méthode du contrôleur retourne 204 NoContent ?",
    "options": [
      "return Ok()",
      "return Empty()",
      "return NoContent()",
      "return None()",
      "return null"
    ],
    "correctAnswer": 2,
    "part": 1
  },
  {
    "id": 55,
    "question": "Dans le routage : [HttpGet(\"{id:int}\")] signifie :",
    "options": [
      "Paramètre optionnel",
      "Paramètre id de type entier obligatoire",
      "Paramètre id de type entier",
      "Identifiant global",
      "Paramètre facultatif"
    ],
    "correctAnswer": 1,
    "part": 1
  },
  {
    "id": 56,
    "question": "Swagger et Scalar sont :",
    "options": [
      "Des UIs de visualisation et test d’API OpenAPI",
      "Des frameworks REST",
      "Des serveurs SQL",
      "Des ORM",
      "Des middlewares d’authentification"
    ],
    "correctAnswer": 0,
    "part": 1
  },
  {
    "id": 57,
    "question": "Le logging natif de Microsoft utilise :",
    "options": [
      "ILogger",
      "Log4Net",
      "EventLog",
      "TraceSource",
      "Serilog"
    ],
    "correctAnswer": 0,
    "part": 1
  },
  {
    "id": 58,
    "question": "Serilog est :",
    "options": [
      "Un ORM",
      "Un moteur SQL",
      "Un framework de logging structuré",
      "Une UI Swagger",
      "Un container DI"
    ],
    "correctAnswer": 2,
    "part": 1
  },
  {
    "id": 59,
    "question": "Pour activer Serilog dans ASP.NET Core :",
    "options": [
      "app.UseLogger()",
      "app.UseSerilogRequestLogging()",
      "builder.AddSerilog()",
      "services.UseSerilog()",
      "logger.Enable()"
    ],
    "correctAnswer": 2,
    "part": 1
  },
  {
    "id": 60,
    "question": "AddSerilog(...) permet :",
    "options": [
      "D’ajouter un middleware",
      "De lire la configuration Serilog depuis appsettings.json",
      "De configurer les endpoints",
      "D’initialiser EF Core",
      "De créer un fichier log manuellement"
    ],
    "correctAnswer": 1,
    "part": 1
  },
  {
    "id": 61,
    "question": "Serilog peut écrire vers :",
    "options": [
      "Console",
      "Fichier",
      "ElasticSearch",
      "EventLog",
      "Toutes les réponses"
    ],
    "correctAnswer": 4,
    "part": 1
  },
  {
    "id": 62,
    "question": "ILogger<WeatherService> injecté dans un service permet :",
    "options": [
      "D’envoyer des mails",
      "De tracer les événements du service dans les logs",
      "D’accéder à EF Core",
      "De gérer les erreurs",
      "D’écrire des fichiers CSV"
    ],
    "correctAnswer": 1,
    "part": 1
  },
  {
    "id": 63,
    "question": "Le middleware app.UseDeveloperExceptionPage() :",
    "options": [
      "Affiche les détails d’erreurs en mode développement",
      "Cache les exceptions",
      "Logue les erreurs dans Serilog",
      "Relance le serveur",
      "Supprime la base"
    ],
    "correctAnswer": 0,
    "part": 1
  },
  {
    "id": 64,
    "question": "AddOpenApi() sert à :",
    "options": [
      "Ajouter EF Core",
      "Générer le document openapi/v1.json",
      "Configurer les routes",
      "Activer Scalar",
      "Ajouter Swagger"
    ],
    "correctAnswer": 1,
    "part": 1
  },
  {
    "id": 65,
    "question": "Les méthodes HTTP principales utilisées dans REST :",
    "options": [
      "Ping, Call, Update, Erase",
      "GET, POST, PUT, DELETE",
      "Fetch, Push, Merge, Clear",
      "Query, Modify, Create, Drop",
      "Sync, Upload, Remove, Refresh"
    ],
    "correctAnswer": 1,
    "part": 1
  },
  {
    "id": 66,
    "question": "app.Run(); :",
    "options": [
      "Crée la base",
      "Démarre le serveur web",
      "Compile l’application",
      "Arrête la base",
      "Logue les erreurs"
    ],
    "correctAnswer": 1,
    "part": 1
  },
  {
    "id": 67,
    "question": "Les filtres API globaux :",
    "options": [
      "S’appliquent à un seul contrôleur",
      "Affectent toutes les requêtes (log, auth, validation)",
      "Ne peuvent être configurés",
      "Existent seulement en MVC",
      "Ne sont pas supportés"
    ],
    "correctAnswer": 1,
    "part": 1
  },
  {
    "id": 68,
    "question": "Le mot clé async sur une méthode API permet :",
    "options": [
      "De gérer les appels asynchrones (I/O non bloquants)",
      "De forcer la synchronicité",
      "De désactiver les exceptions",
      "D’activer LINQ",
      "D’utiliser EF Core"
    ],
    "correctAnswer": 0,
    "part": 1
  },
  {
    "id": 69,
    "question": "Le résultat Results.Ok(obj) appartient à :",
    "options": [
      "IActionResult",
      "HttpResults (Minimal APIs)",
      "ActionResult<T>",
      "ResponseBody",
      "IResponse"
    ],
    "correctAnswer": 1,
    "part": 1
  },
  {
    "id": 70,
    "question": "Code pour retourner 404 avec Minimal API : return Results.NotFound();",
    "options": [
      "Invalide",
      "Nécessite MVC",
      "Correct",
      "Retourne 500",
      "Retourne 204"
    ],
    "correctAnswer": 2,
    "part": 1
  },
  {
    "id": 71,
    "question": "Une bonne pratique pour les erreurs API est :",
    "options": [
      "try/catch dans chaque action",
      "Utiliser un middleware d’erreur global",
      "Ignorer les exceptions",
      "Les cacher avec NoContent",
      "try/catch au niveaudu program.cs"
    ],
    "correctAnswer": 1,
    "part": 1
  },
  {
    "id": 72,
    "question": "Les types de retour conseillés pour API modernes :",
    "options": [
      "void",
      "HttpResponse",
      "ActionResult",
      "ActionResult<T>",
      "Task<object>"
    ],
    "correctAnswer": 3,
    "part": 1
  },
  {
    "id": 73,
    "question": "Dans le cycle API : Requête → Routing → Contrôleur → Action → Réponse. Quelle étape exécute la logique métier ?",
    "options": [
      "Routing",
      "Middleware",
      "Action",
      "Filter",
      "Logger"
    ],
    "correctAnswer": 2,
    "part": 1
  },
  {
    "id": 74,
    "question": "Pour initialiser la base au démarrage :",
    "options": [
      "Créer un scope, puis appeler context.Database.EnsureCreated()",
      "Lancer dotnet ef database update",
      "Utiliser OnModelCreating",
      "Ajouter [InitDatabase]",
      "Modifier appsettings.json"
    ],
    "correctAnswer": 0,
    "part": 1
  },
  {
    "id": 75,
    "question": "Un service injecté avec AddScoped vit :",
    "options": [
      "Pendant tout le cycle de vie de l’application",
      "Le temps d’une requête HTTP",
      "Jusqu’à un redémarrage",
      "Jusqu’à l’appel Dispose()",
      "5 minutes"
    ],
    "correctAnswer": 1,
    "part": 1
  },
  {
    "id": 76,
    "question": "Les niveaux de logs par ordre croissant sont :",
    "options": [
      "Critical < Debug < Error < Information",
      "Debug < Warning < Critical < Trace",
      "Trace < Debug < Information < Warning < Error < Critical",
      "Warning < Trace < Error",
      "Debug < Trace < Warning < Info"
    ],
    "correctAnswer": 2,
    "part": 1
  },
  {
    "id": 77,
    "question": "Le but de la Clean Architecture est :",
    "options": [
      "Séparer les responsabilités et limiter les dépendances",
      "Découpler les couches",
      "Coupler domaine et infrastructure",
      "Éviter les DTO",
      "Améliorer la maintenabilité du code"
    ],
    "correctAnswer": 0,
    "part": 1
  },
  {
    "id": 78,
    "question": "Les 4 couches principales sont :",
    "options": [
      "Controler, Application, Entity, Infrastructure",
      "Presentation, Application, Domain, Infrastructure",
      "Controler, Repository, Service, Model",
      "Presentation, Application, Model, Repository",
      "ORM, DTO, Controller, Logger"
    ],
    "correctAnswer": 1,
    "part": 1
  },
  {
    "id": 79,
    "question": "Le dossier Domain contient :",
    "options": [
      "Les DTO",
      "Les contrôleurs",
      "Les entités métier et la logique pure",
      "Les fichiers de migration",
      "Les vues"
    ],
    "correctAnswer": 2,
    "part": 1
  },
  {
    "id": 80,
    "question": "Un Repository :",
    "options": [
      "Encapsule l’accès aux données",
      "Appelle les contrôleurs",
      "Gère le routage",
      "Supprime les services",
      "Configure EF"
    ],
    "correctAnswer": 0,
    "part": 1
  },
  {
    "id": 81,
    "question": "Un Service de la couche Application :",
    "options": [
      "Définit le schéma SQL",
      "Orchestre les règles métier (use cases)",
      "Gère la configuration",
      "Sérialise les logs",
      "Écrit dans Serilog"
    ],
    "correctAnswer": 1,
    "part": 1
  },
  {
    "id": 82,
    "question": "Un Mapper (Mapperly, AutoMapper…) :",
    "options": [
      "Crée les migrations",
      "Transforme les entités en DTO et inversement",
      "Crée le DbContext",
      "Sauvegarde les données",
      "Lit le fichier appsettings"
    ],
    "correctAnswer": 1,
    "part": 1
  },
  {
    "id": 83,
    "question": "CQRS signifie :",
    "options": [
      "Command Query Responsibility Segregation",
      "Core Query Runtime System",
      "Concurrent Query Routing Service",
      "Command Queue Remote System",
      "Control Query Reset Segment"
    ],
    "correctAnswer": 0,
    "part": 1
  },
  {
    "id": 84,
    "question": "Une Command :",
    "options": [
      "Modifie l’état du système (Create, Update, Delete)",
      "Récupère des données",
      "Fait un SELECT",
      "Supprime les logs",
      "Configure l’API"
    ],
    "correctAnswer": 0,
    "part": 1
  },
  {
    "id": 85,
    "question": "Une Query :",
    "options": [
      "Modifie les données",
      "Lit des données sans effet de bord",
      "Supprime des entités",
      "Gère les logs",
      "Déclenche les migrations"
    ],
    "correctAnswer": 1,
    "part": 1
  },
  {
    "id": 86,
    "question": "Les DTO servent à :",
    "options": [
      "Transférer des fichiers",
      "Transférer des données entre couches",
      "Gérer les logs",
      "Créer la DB",
      "Limiter les données envoyées au client"
    ],
    "correctAnswer": 1,
    "part": 1
  },
  {
    "id": 87,
    "part": 2,
    "question": "Définition : \"ORM pour gérer la base de données depuis du code C#.\"",
    "options": [
      "Entity Framework Core",
      "Cascade Delete",
      "Service Layer",
      "Migration",
      "Scaffold"
    ],
    "correctAnswer": 0
  },
  {
    "id": 88,
    "part": 2,
    "question": "Définition : \"Classe représentant la session avec la base et les entités.\"",
    "options": [
      "DbContext",
      "Clean Architecture",
      "Application Layer",
      "Connection String",
      "Entity Framework Core"
    ],
    "correctAnswer": 0
  },
  {
    "id": 89,
    "part": 2,
    "question": "Définition : \"Collection d’entités d’un type spécifique dans le DbContext.\"",
    "options": [
      "Entity Framework Core",
      "Serilog",
      "DbSet",
      "Cascade Delete",
      "Repository Pattern"
    ],
    "correctAnswer": 2
  },
  {
    "id": 90,
    "part": 2,
    "question": "Définition : \"Fichier qui modifie ou crée le schéma de la base.\"",
    "options": [
      "Migration",
      "EntityState",
      "CQRS",
      "Application Layer",
      "Entity Framework Core"
    ],
    "correctAnswer": 0
  },
  {
    "id": 91,
    "part": 2,
    "question": "Définition : \"Configuration des entités via code C# plutôt qu’attributs.\"",
    "options": [
      "Data Annotation",
      "Connection String",
      "Fluent API",
      "EntityState",
      "DbContext"
    ],
    "correctAnswer": 2
  },
  {
    "id": 92,
    "part": 2,
    "question": "Définition : \"Attributs C# pour configurer les entités et colonnes.\"",
    "options": [
      "Cascade Delete",
      "Data Annotation",
      "Entity Framework Core",
      "Dependency Injection (DI)",
      "Scaffold"
    ],
    "correctAnswer": 1
  },
  {
    "id": 93,
    "part": 2,
    "question": "Définition : \"Syntaxe C# pour interroger collections et bases de données.\"",
    "options": [
      "DbSet",
      "DTO (Data Transfer Object)",
      "Migration",
      "LINQ",
      "Cascade Delete"
    ],
    "correctAnswer": 3
  },
  {
    "id": 94,
    "part": 2,
    "question": "Définition : \"État d’une entité suivi par EF Core (Added, Modified, Deleted…).\"",
    "options": [
      "Migration",
      "Service Layer",
      "CQRS",
      "EntityState",
      "Dependency Injection (DI)"
    ],
    "correctAnswer": 3
  },
  {
    "id": 95,
    "part": 2,
    "question": "Définition : \"Supprime automatiquement les entités enfants lors de la suppression du parent.\"",
    "options": [
      "CQRS",
      "Entity Framework Core",
      "DbContext",
      "Cascade Delete",
      "DTO (Data Transfer Object)"
    ],
    "correctAnswer": 3
  },
  {
    "id": 96,
    "part": 2,
    "question": "Définition : \"DbContext – Génère le modèle EF Core à partir d’une base existante.\"",
    "options": [
      "Swagger / OpenAPI",
      "Dependency Injection (DI)",
      "CQRS",
      "Scaffold",
      "DbSet"
    ],
    "correctAnswer": 3
  },
  {
    "id": 97,
    "part": 2,
    "question": "Définition : \"Chaîne définissant comment se connecter à la base de données.\"",
    "options": [
      "Connection String",
      "Entity Framework Core",
      "Infrastructure Layer",
      "Clean Architecture",
      "Serilog"
    ],
    "correctAnswer": 0
  },
  {
    "id": 98,
    "part": 2,
    "question": "Définition : \"Composant de traitement d’une requête dans le pipeline ASP.NET Core.\"",
    "options": [
      "Middleware",
      "Dependency Injection (DI)",
      "Connection String",
      "Serilog",
      "Entity Framework Core"
    ],
    "correctAnswer": 0
  },
  {
    "id": 99,
    "part": 2,
    "question": "Définition : \"Injection automatique des dépendances dans les classes.\"",
    "options": [
      "ActionResult",
      "Clean Architecture",
      "CQRS",
      "Swagger / OpenAPI",
      "Dependency Injection (DI)"
    ],
    "correctAnswer": 4
  },
  {
    "id": 100,
    "part": 2,
    "question": "Définition : \"Type de retour d’une action contrôleur combinant données et statut HTTP.\"",
    "options": [
      "Serilog",
      "Clean Architecture",
      "ActionResult",
      "EntityState",
      "Service Layer"
    ],
    "correctAnswer": 2
  },
  {
    "id": 101,
    "part": 2,
    "question": "Définition : \"Outils pour documenter et tester les API REST.\"",
    "options": [
      "Entity Framework Core",
      "Middleware",
      "EntityState",
      "Swagger / OpenAPI",
      "DbContext"
    ],
    "correctAnswer": 3
  },
  {
    "id": 102,
    "part": 2,
    "question": "Définition : \"Framework de logging structuré pour applications .NET.\"",
    "options": [
      "ActionResult",
      "LINQ",
      "Connection String",
      "Migration",
      "Serilog"
    ],
    "correctAnswer": 4
  },
  {
    "id": 103,
    "part": 2,
    "question": "Définition : \"Organisation du code en couches séparant responsabilités et dépendances.\"",
    "options": [
      "Service Layer",
      "Migration",
      "LINQ",
      "Middleware",
      "Clean Architecture"
    ],
    "correctAnswer": 4
  },
  {
    "id": 104,
    "part": 2,
    "question": "Définition : \"Contient les entités métier et la logique pure.\"",
    "options": [
      "Domain Layer",
      "DbSet",
      "CQRS",
      "Entity Framework Core",
      "Clean Architecture"
    ],
    "correctAnswer": 0
  },
  {
    "id": 105,
    "part": 2,
    "question": "Définition : \"Contient la logique d’orchestration et les cas d’usage.\"",
    "options": [
      "Application Layer",
      "Swagger / OpenAPI",
      "Middleware",
      "ActionResult",
      "Migration"
    ],
    "correctAnswer": 0
  },
  {
    "id": 106,
    "part": 2,
    "question": "Définition : \"Gère l’accès aux données, API externes et services techniques.\"",
    "options": [
      "DbSet",
      "LINQ",
      "DTO (Data Transfer Object)",
      "EntityState",
      "Infrastructure Layer"
    ],
    "correctAnswer": 4
  },
  {
    "id": 107,
    "part": 2,
    "question": "Définition : \"Classe qui encapsule l’accès aux données pour une entité.\"",
    "options": [
      "Cascade Delete",
      "Repository Pattern",
      "Application Layer",
      "Domain Layer",
      "Serilog"
    ],
    "correctAnswer": 1
  },
  {
    "id": 108,
    "part": 2,
    "question": "Définition : \"Contient la logique métier réutilisable par l’application.\"",
    "options": [
      "Application Layer",
      "Migration",
      "Mapperly",
      "Service Layer",
      "Clean Architecture"
    ],
    "correctAnswer": 3
  },
  {
    "id": 109,
    "part": 2,
    "question": "Définition : \"Objet pour transférer uniquement les données nécessaires entre couches.\"",
    "options": [
      "Clean Architecture",
      "ActionResult",
      "DTO (Data Transfer Object)",
      "Swagger / OpenAPI",
      "Connection String"
    ],
    "correctAnswer": 2
  },
  {
    "id": 110,
    "part": 2,
    "question": "Définition : \"Outil pour convertir automatiquement entités ↔ DTO.\"",
    "options": [
      "Mapperly",
      "Clean Architecture",
      "LINQ",
      "Migration",
      "Swagger / OpenAPI"
    ],
    "correctAnswer": 0
  },
  {
    "id": 111,
    "part": 2,
    "question": "Définition : \"Sépare les opérations de lecture (Query) et d’écriture (Command) sur les données.\"",
    "options": [
      "Repository Pattern",
      "DTO (Data Transfer Object)",
      "Migration",
      "ActionResult",
      "CQRS"
    ],
    "correctAnswer": 4
  },
  {
    "id": 112,
    "question": "Lorsqu’une entité est lue via un DbContext, puis modifiée sans appel à Attach ou Update, EF Core :",
    "options": [
      "Lève une exception de suivi incohérent",
      "Ignore la modification",
      "La détecte automatiquement si elle est suivie par le ChangeTracker",
      "Modifie toutes les lignes correspondantes",
      "Nécessite explicitement context.Entry(entity).State = Modified"
    ],
    "correctAnswer": 2,
    "part": 3
  },
  {
    "id": 113,
    "question": "Le comportement de context.Attach(entity) dépend de :",
    "options": [
      "Si la clé primaire est renseignée ou non",
      "L’état courant de l’entité",
      "Les entités enfants rattachées",
      "Le mode de suivi du contexte",
      "Toutes ces réponses"
    ],
    "correctAnswer": 0,
    "part": 3
  },
  {
    "id": 114,
    "question": "Lors d’un SaveChanges(), EF Core :",
    "options": [
      "Génère un script SQL et l’exécute sans transaction",
      "Utilise une transaction implicite regroupant les modifications suivies",
      "Valide chaque entité individuellement",
      "Envoie un batch par propriété modifiée",
      "Dépend du provider de base de données uniquement"
    ],
    "correctAnswer": 1,
    "part": 3
  },
  {
    "id": 115,
    "question": "Si deux DbContext différents chargent la même entité et que chacun la modifie avant SaveChanges(), EF :",
    "options": [
      "Écrase silencieusement le dernier enregistrement",
      "Lance une exception d’accès concurrent",
      "Ne détecte pas le conflit sauf si une colonne de concurrence est configurée",
      "Synchronise automatiquement les changements",
      "Fusionne les versions"
    ],
    "correctAnswer": 2,
    "part": 3
  },
  {
    "id": 116,
    "question": "Quelle est la différence entre Add() et Attach() ?",
    "options": [
      "Attach crée une nouvelle entité, Add la réutilise",
      "Add attache mais ne change pas l’état",
      "Add marque l’entité comme Added, Attach comme Unchanged",
      "Elles sont équivalentes",
      "Attach ne fonctionne que sur les entités enfants"
    ],
    "correctAnswer": 2,
    "part": 3
  },
  {
    "id": 117,
    "question": "Un DbContext ne doit généralement pas être enregistré en Singleton car :",
    "options": [
      "Il ne gère pas le multithreading",
      "Il ne supporte pas les transactions longues",
      "Son ChangeTracker accumule les entités",
      "Il est conçu pour une durée de vie courte (Scoped)",
      "Toutes ces réponses"
    ],
    "correctAnswer": 4,
    "part": 3
  },
  {
    "id": 118,
    "question": "Quelle instruction crée réellement la table en base dans une approche Code-First ?",
    "options": [
      "EnsureCreated()",
      "Add-Migration",
      "Update-Database",
      "Migrate()",
      "context.SaveChanges()"
    ],
    "correctAnswer": 2,
    "part": 3
  },
  {
    "id": 119,
    "question": "Les conventions par défaut d’EF Core :",
    "options": [
      "Imposent les noms de colonnes en majuscules",
      "Ne peuvent pas être surchargées",
      "Peuvent être remplacées via Fluent API ou annotations",
      "Sont désactivées par défaut",
      "N’agissent que sur les clés étrangères"
    ],
    "correctAnswer": 2,
    "part": 3
  },
  {
    "id": 120,
    "question": "Lorsqu’un DbContext suit deux entités ayant la même clé primaire :",
    "options": [
      "EF met à jour la plus récente",
      "EF crée deux lignes",
      "Une exception InvalidOperationException est levée",
      "Les deux sont fusionnées",
      "Rien ne se passe"
    ],
    "correctAnswer": 2,
    "part": 3
  },
  {
    "id": 121,
    "question": "Le ChangeTracker.AutoDetectChangesEnabled désactivé permet :",
    "options": [
      "D’empêcher la détection de modifications automatiques",
      "D’optimiser les opérations massives (batch)",
      "De désactiver la persistance",
      "De supprimer le contexte",
      "De rendre SaveChanges() instantané"
    ],
    "correctAnswer": 1,
    "part": 3
  },
  {
    "id": 122,
    "question": "La suppression en cascade implicite s’applique :",
    "options": [
      "À toutes les relations",
      "Seulement si la relation est Required (non nullable)",
      "Seulement si DeleteBehavior.Cascade est explicite",
      "Jamais, par sécurité",
      "Pour toutes les entités enfants"
    ],
    "correctAnswer": 1,
    "part": 3
  },
  {
    "id": 123,
    "question": "Quelle est la sortie SQL la plus probable du code suivant : context.Students.Where(s => s.Grade.GradeName == \"A\");",
    "options": [
      "Un JOIN avec la table Grade",
      "Une sous-requête",
      "Une requête cartésienne",
      "Un SELECT sur Students uniquement",
      "Une exception de mapping"
    ],
    "correctAnswer": 0,
    "part": 3
  },
  {
    "id": 124,
    "question": "Dans un modèle Many-to-Many sans entité de jointure explicite, EF Core :",
    "options": [
      "Crée une entité Join implicite",
      "Crée une table de liaison sans classe dédiée",
      "Requiert [ForeignKey] manuelle",
      "Nécessite une configuration One-to-Many double",
      "Ne supporte pas ce scénario"
    ],
    "correctAnswer": 1,
    "part": 3
  },
  {
    "id": 125,
    "question": "Quelle est la conséquence de context.ChangeTracker.Clear() ?",
    "options": [
      "Supprime la base",
      "Détache toutes les entités suivies",
      "Vide les tables",
      "Enregistre les changements",
      "Met les entités à Unchanged"
    ],
    "correctAnswer": 1,
    "part": 3
  },
  {
    "id": 126,
    "question": "Une migration EF Core contient :",
    "options": [
      "Un snapshot du modèle + le code SQL des modifications",
      "Des métadonnées JSON",
      "Deux classes : une Migration et un ModelSnapshot",
      "Des scripts SQL exécutables",
      "Des triggers automatiques"
    ],
    "correctAnswer": 0,
    "part": 3
  },
  {
    "id": 127,
    "question": "Si Database.EnsureCreated() est utilisé avant une migration :",
    "options": [
      "La migration suivante l’écrase",
      "Les migrations ne pourront plus être appliquées sans supprimer la DB",
      "Les migrations s’empilent",
      "EF fusionne les deux schémas",
      "Rien ne change"
    ],
    "correctAnswer": 1,
    "part": 3
  },
  {
    "id": 128,
    "question": "Le code : context.Entry(student).State = EntityState.Detached;",
    "options": [
      "Sauvegarde l’entité",
      "Détache l’entité du contexte, elle n’est plus suivie",
      "Supprime la ligne en DB",
      "Rattache une entité",
      "Fait un rollback"
    ],
    "correctAnswer": 1,
    "part": 3
  },
  {
    "id": 129,
    "question": "LINQ to Entities :",
    "options": [
      "Utilise des itérateurs C#",
      "Exécute la requête côté client",
      "Traduit l’expression en SQL exécuté côté serveur",
      "Crée un cache mémoire",
      "Est identique à LINQ to Objects"
    ],
    "correctAnswer": 2,
    "part": 3
  },
  {
    "id": 130,
    "question": "FirstOrDefault() sur un IQueryable EF Core :",
    "options": [
      "Charge tout le dataset",
      "Exécute immédiatement la requête SQL avec TOP 1",
      "Retourne un proxy non chargé",
      "Retourne null si rien n’est trouvé",
      "Crée une collection vide si rien n’est trouvé"
    ],
    "correctAnswer": 1,
    "part": 3
  },
  {
    "id": 131,
    "question": "La commande dotnet ef migrations add Init --context AppContext :",
    "options": [
      "Ajoute une migration en précisant la classe de contexte",
      "Crée la base",
      "Liste les migrations",
      "Ajoute une première migration",
      "Applique la migration"
    ],
    "correctAnswer": 0,
    "part": 3
  },
  {
    "id": 132,
    "question": "Quelle différence principale existe entre AsEnumerable() et AsNoTracking() sur une requête EF Core ?",
    "options": [
      "AsEnumerable() exécute la requête en mémoire",
      "AsNoTracking() désactive la détection des modifications",
      "AsEnumerable() conserve le tracking",
      "AsNoTracking() est plus léger pour la lecture seule",
      "Toutes ces réponses sont correctes"
    ],
    "correctAnswer": 4,
    "part": 3
  },
  {
    "id": 133,
    "question": "Le code suivant : var s = context.Students.First(); s.Name = \"Karl\"; context.SaveChanges(); Que fait EF Core ?",
    "options": [
      "N’enregistre pas le changement sans Update()",
      "Détecte la modification et exécute un UPDATE SQL",
      "Crée un nouvel enregistrement",
      "Déclenche une exception si la table est vide",
      "Met la ligne à Unchanged"
    ],
    "correctAnswer": 1,
    "part": 3
  },
  {
    "id": 134,
    "question": "Lorsqu’une propriété Navigation est marquée virtual, EF Core :",
    "options": [
      "Crée un proxy dynamique pour le lazy loading",
      "Peut différer le chargement des données liées",
      "Nécessite Microsoft.EntityFrameworkCore.Proxies",
      "Désactive le tracking",
      "Ne supporte pas le Include()"
    ],
    "correctAnswer": 1,
    "part": 3
  },
  {
    "id": 135,
    "question": "L’option UseQueryTrackingBehavior(QueryTrackingBehavior.NoTracking) configurée globalement :",
    "options": [
      "Désactive les transactions",
      "Désactive par défaut le suivi des entités retournées",
      "Rend la lecture plus performante",
      "Bloque SaveChanges()",
      "Nécessite un rechargement manuel pour modifier"
    ],
    "correctAnswer": 1,
    "part": 3
  },
  {
    "id": 136,
    "question": "Quel est le résultat de ce code ? context.Students.Where(s => s.Id == 1).FirstOrDefault(); context.Students.Where(s => s.Id == 1).FirstOrDefault();",
    "options": [
      "Une seule requête SQL est exécutée grâce au cache EF",
      "Deux requêtes SQL sont exécutées, pas de cache de requête par défaut",
      "La seconde lève une exception de suivi",
      "Une transaction est ouverte",
      "Le premier résultat reste en mémoire partagée"
    ],
    "correctAnswer": 1,
    "part": 3
  },
  {
    "id": 137,
    "question": "Les Shadow Properties dans EF Core :",
    "options": [
      "Sont des propriétés non déclarées dans la classe C# mais suivies par EF",
      "Permettent de stocker des métadonnées internes (FK, timestamps, etc.)",
      "Ne sont accessibles que via Entry().Property(\"Nom\")",
      "Peuvent être persistées en base",
      "Toutes ces réponses"
    ],
    "correctAnswer": 4,
    "part": 3
  },
  {
    "id": 138,
    "question": "Le type de suppression DeleteBehavior.ClientSetNull :",
    "options": [
      "Supprime les enfants en base",
      "Met à null les FK en mémoire, sans propager en DB avant SaveChanges()",
      "Dépend de la transaction",
      "Supprime aussi le parent",
      "Déconnecte le contexte"
    ],
    "correctAnswer": 1,
    "part": 3
  },
  {
    "id": 139,
    "question": "Les Owned Types :",
    "options": [
      "Sont stockés dans la même table que l’entité propriétaire",
      "Représentent des objets de valeur sans clé propre",
      "Ne peuvent être partagés entre entités",
      "Nécessitent Fluent API",
      "Toutes ces réponses"
    ],
    "correctAnswer": 4,
    "part": 3
  },
  {
    "id": 140,
    "question": "Pour qu’une propriété DateCreated soit automatiquement remplie lors de l’insertion :",
    "options": [
      "[DatabaseGenerated(DatabaseGeneratedOption.Computed)]",
      "[DefaultValue(\"getdate()\")]",
      "Configuration via Fluent API .HasDefaultValueSql(\"getutcdate()\")",
      "[Timestamp]",
      "Nécessite un trigger SQL"
    ],
    "correctAnswer": 2,
    "part": 3
  },
  {
    "id": 141,
    "question": "Les requêtes composées sur IQueryable EF Core sont :",
    "options": [
      "Exécutées immédiatement",
      "Construites en expression tree et traduites à l’exécution (deferred execution)",
      "Stockées en cache jusqu’à ToList()",
      "Exécutées ligne par ligne",
      "Converties en LINQ to Objects"
    ],
    "correctAnswer": 1,
    "part": 3
  },
  {
    "id": 142,
    "question": "Le code suivant : var stud = new Student { Id = 10, Name = \"Karl\" }; context.Update(stud); Suppose que l’étudiant existe déjà.",
    "options": [
      "Marque l’entité comme Modified sans la lire",
      "Charge la ligne depuis la base",
      "Lève une exception s’il n’existe pas",
      "Supprime les relations",
      "Nécessite un SaveChanges() pour exécuter le SQL"
    ],
    "correctAnswer": 0,
    "part": 3
  },
  {
    "id": 143,
    "question": "Quelle pratique est déconseillée pour les performances EF ?",
    "options": [
      "Include() sur plusieurs niveaux de profondeur",
      "ToList() avant Where()",
      "Charger 10 000 entités trackées",
      "Exécuter SaveChanges() dans une boucle",
      "Toutes ces pratiques sont déconseillées"
    ],
    "correctAnswer": 4,
    "part": 3
  },
  {
    "id": 144,
    "question": "Les clés composites sont configurées via :",
    "options": [
      "[Key(\"A\",\"B\")]",
      "[CompositeKey]",
      "modelBuilder.Entity<T>().HasKey(e => new { e.A, e.B })",
      "AddCompositeKey()",
      "Non supporté par EF"
    ],
    "correctAnswer": 2,
    "part": 3
  },
  {
    "id": 145,
    "question": "Le mode SingleOrDefault() :",
    "options": [
      "Lève une exception si plus d’une correspondance existe",
      "Retourne null si aucune entité",
      "Peut charger plus lentement qu’un FirstOrDefault()",
      "Combine filtrage + validation d’unicité",
      "Ne peut pas être traduit en SQL"
    ],
    "correctAnswer": 0,
    "part": 3
  },
  {
    "id": 146,
    "question": "Les Compiled Queries d’EF Core servent à :",
    "options": [
      "Exécuter du SQL brut",
      "Précompiler l’arbre d’expression pour réutilisation (gain de perf)",
      "Créer des index",
      "Générer des migrations automatiques",
      "Sauvegarder le contexte"
    ],
    "correctAnswer": 1,
    "part": 3
  },
  {
    "id": 147,
    "question": "Quel scénario nécessite le TransactionScope ?",
    "options": [
      "SaveChanges() standard",
      "Modification de plusieurs contextes ou sources de données dans la même transaction",
      "Lazy Loading",
      "Delete cascade",
      "Mapping complexe"
    ],
    "correctAnswer": 1,
    "part": 3
  },
  {
    "id": 148,
    "question": "L’option .UseLazyLoadingProxies() :",
    "options": [
      "Est activée par défaut",
      "Nécessite les propriétés virtual",
      "Crée des proxys dynamiques pour charger les données à la demande",
      "Affecte les performances",
      "Réponses : B, C, D"
    ],
    "correctAnswer": 4,
    "part": 3
  },
  {
    "id": 149,
    "question": "Quelle différence entre Find() et FirstOrDefault() ?",
    "options": [
      "Find() cherche d’abord dans le cache du contexte avant la DB",
      "Find() nécessite la clé primaire",
      "FirstOrDefault() exécute toujours une requête SQL",
      "Find() est plus rapide si l’entité est déjà suivie",
      "Toutes ces réponses"
    ],
    "correctAnswer": 4,
    "part": 3
  },
  {
    "id": 150,
    "question": "Une migration contenant un renommage de colonne et un changement de type :",
    "options": [
      "Est exécutée en une seule commande SQL",
      "Peut générer un DROP + CREATE selon le provider",
      "Ne peut pas être rollbackée",
      "N’est pas détectée automatiquement",
      "Supprime la contrainte FK associée"
    ],
    "correctAnswer": 1,
    "part": 3
  },
  {
    "id": 151,
    "question": "Pour insérer des données initiales conditionnelles :",
    "options": [
      "[SeedData]",
      "Utiliser HasData() dans OnModelCreating",
      "Créer une classe statique DbSeeder exécutée au démarrage",
      "Ajouter une migration spéciale",
      "Utiliser context.Database.Migrate()"
    ],
    "correctAnswer": 2,
    "part": 3
  },
  {
    "id": 152,
    "question": "Différence principale Middleware vs Filter en Web API :",
    "options": [
      "Les filters s’exécutent avant le routing",
      "Les middlewares enveloppent tout le pipeline, les filters ciblent contrôleurs/actions",
      "Les filters ont accès au ModelState et aux résultats d’action",
      "Les middlewares ne peuvent pas court-circuiter la réponse",
      "Les middlewares peuvent s’appliquer aux fichiers statiques et endpoints non-API"
    ],
    "correctAnswer": 1,
    "part": 3
  },
  {
    "id": 153,
    "question": "En Minimal APIs, que renvoie le plus précisément Results.NotFound() ?",
    "options": [
      "ActionResult",
      "IActionResult",
      "Un IResult (implémentation HttpResults)",
      "ProblemDetails",
      "HttpResponseMessage"
    ],
    "correctAnswer": 2,
    "part": 3
  },
  {
    "id": 154,
    "question": "Pour masquer la validation implicite d’[ApiController] et gérer toi-même la réponse :",
    "options": [
      "Supprimer [ApiController]",
      "Désactiver SuppressModelStateInvalidFilter",
      "Utiliser [ValidateNever] sur le type",
      "Intercepter via un ActionFilter et tester ModelState.IsValid",
      "app.Services.DisableValidation()"
    ],
    "correctAnswer": 1,
    "part": 3
  },
  {
    "id": 155,
    "question": "Concernant ActionResult<T> :",
    "options": [
      "Empêche de retourner NotFound()",
      "Permet de retourner soit un T, soit un IActionResult",
      "Sérialise T et force 200 OK",
      "Expose le type pour la doc OpenAPI plus précisément qu’un IActionResult",
      "N’est pas compatible avec async"
    ],
    "correctAnswer": 1,
    "part": 3
  },
  {
    "id": 156,
    "question": "[FromBody] vs [FromQuery] : comportement par défaut en API :",
    "options": [
      "Les paramètres simples viennent du body par défaut",
      "Un seul paramètre [FromBody] par action en JSON (par défaut)",
      "Les paramètres complexes (classe) viennent du body par défaut",
      "Les paramètres simples (string, int) viennent du body",
      "Les paramètres simples viennent de la query/route par défaut"
    ],
    "correctAnswer": 2,
    "part": 3
  },
  {
    "id": 157,
    "question": "ILogger<T> : lequel est vrai ?",
    "options": [
      "Les messages interpolés sont toujours structurés",
      "Utiliser des “message templates” logger.LogInformation(\"User {Id} ...\", id) crée des champs structurés",
      "Écrire des objets comme {@obj} n’est supporté que par STJ",
      "ILogger nécessite Serilog",
      "Le nom de catégorie du log “category name” est le nom de T par défaut"
    ],
    "correctAnswer": 1,
    "part": 3
  },
  {
    "id": 158,
    "question": "Serilog avec ASP.NET Core pour journaliser chaque requête :",
    "options": [
      "Ajouter UseLogging()",
      "app.UseSerilogRequestLogging()",
      "Logger uniquement en Production",
      "Possibilité d’enrichir (ex: WithMachineName, FromLogContext) via config",
      "Oblige le format JSON"
    ],
    "correctAnswer": 1,
    "part": 3
  },
  {
    "id": 159,
    "question": "Configurer Swagger/Scalar en .NET 9 :",
    "options": [
      "builder.Services.AddOpenApi()",
      "app.UseSwagger() obligatoire",
      "app.MapOpenApi() pour exposer /openapi/v1.json",
      "app.MapScalarApiReference() pour l’UI Scalar",
      "app.UseOpenApiUI()"
    ],
    "correctAnswer": 2,
    "part": 3
  },
  {
    "id": 160,
    "question": "CancellationToken dans une action :",
    "options": [
      "Peut être passé en paramètre pour annuler un await db.ToListAsync(ct)",
      "Inutile pour EF Core",
      "Désactive le time-out",
      "Est alimenté par la fermeture de la connexion HTTP",
      "N’est disponible qu’en Minimal API"
    ],
    "correctAnswer": 0,
    "part": 3
  },
  {
    "id": 161,
    "question": "Choisir la durée de vie DI appropriée :",
    "options": [
      "DbContext en Singleton pour réduire les allocations",
      "HttpClient en Scoped par défaut",
      "DbContext en Scoped (requête)",
      "Services stateless (Mapper, Validator) souvent en Transient",
      "Caches/configuration (lecture) en Singleton"
    ],
    "correctAnswer": 2,
    "part": 3
  },
  {
    "id": 162,
    "question": "Pour valider un modèle d’entrée (DTO) avec des règles avancées :",
    "options": [
      "[RegularExpression] uniquement",
      "FluentValidation (librairie tierce) ou DataAnnotations",
      "Créer un ActionFilter de validation pour format unifié des erreurs",
      "Valider le DTO dans le contrôleur",
      "ModelState est obsolète"
    ],
    "correctAnswer": 1,
    "part": 3
  },
  {
    "id": 163,
    "question": "Pagination propre en Web API :",
    "options": [
      "Prendre tout puis paginer en mémoire",
      "Retourner des métadonnées (page, size, total) dans des en-têtes ou un enveloppe JSON",
      "Limiter pageSize max côté serveur",
      "Utiliser AsNoTracking pour les listes",
      "Ignorer la stabilité d’ordre"
    ],
    "correctAnswer": 1,
    "part": 3
  },
  {
    "id": 164,
    "question": "Minimal APIs vs Controllers :",
    "options": [
      "Minimal = pas de filtres possible",
      "Minimal expose des endpoints fonctionnels, léger pour microservices",
      "Controllers = filtres + conventions MVC + attributs riches",
      "Minimal interdit DI",
      "Minimal renvoie des IResult, contrôleur renvoie ActionResult<T>"
    ],
    "correctAnswer": 1,
    "part": 3
  },
  {
    "id": 165,
    "question": "Global exception handling recommandé :",
    "options": [
      "try/catch dans chaque action",
      "Middleware global + mapping → ProblemDetails standard",
      "Filtres d’exception uniquement",
      "Rediriger vers /error en production",
      "Journaliser (corrélation Id) + ne pas divulguer les détails en prod"
    ],
    "correctAnswer": 1,
    "part": 3
  },
  {
    "id": 166,
    "question": "Routing : contraintes et noms :",
    "options": [
      "[HttpGet(\"{id:int}\")] contraint id à un entier",
      "Le nom d’une route (ex. :GetByName) doit être unique quel que soit le contrôleur",
      "Les routes nommées ne servent qu’à la doc",
      "Des paramètres optionnels \"{category?}\" sont possibles",
      "* capture un segment, ** plusieurs (catch-all)"
    ],
    "correctAnswer": 0,
    "part": 3
  },
  {
    "id": 167,
    "question": "Content negotiation :",
    "options": [
      "Par défaut JSON via System.Text.Json",
      "Accept: application/xml est toujours respecté sans config",
      "On peut ajouter un formatter XML",
      "text/csv est pris en charge nativement",
      "La négociation peut renvoyer 406 si non supporté (si configuré)"
    ],
    "correctAnswer": 0,
    "part": 3
  },
  {
    "id": 168,
    "question": "OpenAPI doc :",
    "options": [
      "Toujours exposer /openapi/v1.json en prod sans auth",
      "Protéger l’UI (Swagger/Scalar) en prod ou la désactiver",
      "Décrire les schémas, codes de retour, auth (OAuth2/Bearer)",
      "Générer automatiquement des clients sans configuration",
      "MapOpenApi() supporte plusieurs versions"
    ],
    "correctAnswer": 2,
    "part": 3
  },
  {
    "id": 169,
    "question": "Performance — anti-patterns courants :",
    "options": [
      "Serializer synchro sur gros payloads",
      "ToList() prématuré avant Where/Select",
      "Logging verbeux au niveau Debug/Trace en prod",
      "AsNoTracking() pour lecture seule",
      "SaveChanges() dans une boucle au lieu de batch"
    ],
    "correctAnswer": 3,
    "part": 3
  },
  {
    "id": 170,
    "question": "HttpLoggingMiddleware :",
    "options": [
      "Peut journaliser headers, requête, réponse",
      "Toujours recommandé en prod sans filtre",
      "Risque de fuite de données sensibles si mal configuré",
      "Ne fonctionne pas avec HTTPS",
      "Peut dégrader la perf si on logge les bodies volumineux"
    ],
    "correctAnswer": 0,
    "part": 3
  },
  {
    "id": 171,
    "question": "DI circular dependency :",
    "options": [
      "Peut provoquer des boucles d’initialisation et exceptions",
      "Résolu automatiquement par le conteneur",
      "Souvent signe d’un design à refactorer",
      "Résolu en changeant toutes les durées de vie en Singleton",
      "Parfois corrigé en introduisant des ports/interfaces plus fins"
    ],
    "correctAnswer": 2,
    "part": 3
  },
  {
    "id": 172,
    "question": "JSON patch / partial updates :",
    "options": [
      "HttpPatch non supporté",
      "Supporté uniquement via Newtonsoft",
      "Valider les opérations patch et la sécurité (chemins autorisés)",
      "Toujours préférable à PUT",
      "Penser à la concurrence (RowVersion)"
    ],
    "correctAnswer": 2,
    "part": 3
  },
  {
    "id": 173,
    "question": "La Clean Architecture vise avant tout à :",
    "options": [
      "Réduire le couplage entre UI et données",
      "Faire dépendre le code métier uniquement d’abstractions",
      "Isoler le domaine de toute technologie (framework, base, UI)",
      "Utiliser CQRS obligatoirement",
      "Faciliter le test unitaire et la maintenabilité dans le temps"
    ],
    "correctAnswer": 4,
    "part": 3
  },
  {
    "id": 174,
    "question": "Dans une architecture en couches proprement isolée :",
    "options": [
      "La couche Presentation référence la couche Domain directement",
      "La couche Application référence le Domain et expose des interfaces implémentées dans Infrastructure",
      "Infrastructure connaît Application mais pas l’inverse",
      "Les dépendances vont toujours du haut (UI) vers le bas (Domain)",
      "Les DTO peuvent être définis dans Domain"
    ],
    "correctAnswer": 2,
    "part": 3
  },
  {
    "id": 175,
    "question": "Le pattern Repository permet :",
    "options": [
      "De remplacer les requêtes SQL par LINQ",
      "D’avoir un accès direct au contexte EF",
      "D’encapsuler la logique d’accès aux données derrière une interface abstraite",
      "De rendre les tests possibles avec des mocks ou bases InMemory",
      "D’utiliser EF Core"
    ],
    "correctAnswer": 2,
    "part": 3
  },
  {
    "id": 176,
    "question": "Quel est le rôle d’un Service d’application dans la Clean Architecture ?",
    "options": [
      "Orchestrer les règles métier entre plusieurs entités et repositories",
      "Remplacer le contrôleur",
      "Coordonner le mapping entité ↔ DTO et déclencher des transactions",
      "Implémenter la logique de validation HTTP",
      "Exécuter directement les requêtes SQL"
    ],
    "correctAnswer": 0,
    "part": 3
  },
  {
    "id": 177,
    "question": "Le Domain Layer devrait contenir :",
    "options": [
      "Des entités, des value objects, et les règles métier pures",
      "Les classes de configuration EF",
      "Les contrôleurs",
      "Aucune dépendance vers Entity Framework ou ASP.NET Core",
      "Les DTO d’entrée API"
    ],
    "correctAnswer": 0,
    "part": 3
  },
  {
    "id": 178,
    "question": "Le CQRS (Command Query Responsibility Segregation) :",
    "options": [
      "Sépare les modèles de lecture et d’écriture",
      "Nécessite deux bases de données distinctes",
      "Améliore la scalabilité et la clarté des intentions (read/write)",
      "Est obligatoire pour tout projet EF Core",
      "Peut coexister avec Mediator / MediatR"
    ],
    "correctAnswer": 0,
    "part": 3
  },
  {
    "id": 179,
    "question": "Dans une implémentation CQRS avec MediatR :",
    "options": [
      "Chaque Command ou Query est un objet envoyé à un Handler",
      "Le Handler retourne toujours IActionResult",
      "Les Commands modifient l’état, les Queries ne doivent avoir aucun effet de bord",
      "Plusieurs handlers peuvent traiter une même commande simultanément",
      "Le Mediator centralise les appels pour découpler les dépendances directes"
    ],
    "correctAnswer": 4,
    "part": 3
  },
  {
    "id": 180,
    "question": "Pourquoi ne pas exposer les entités EF Core directement via l’API ?",
    "options": [
      "Cela simplifie la maintenance",
      "Fuite de la structure interne de la base (casse les clients à chaque évolution)",
      "Risque de référence circulaire et sérialisation infinie",
      "Violation du principe de séparation entre modèle métier et contrat d’exposition (DTO)",
      "Les entités ne sont pas sérialisables"
    ],
    "correctAnswer": 3,
    "part": 3
  },
  {
    "id": 181,
    "question": "Le mapping entité ↔ DTO :",
    "options": [
      "Doit toujours être manuel",
      "Peut être automatisé par des frameworks (Mapperly, AutoMapper)",
      "Peut être généré compile-time (Mapperly) pour éviter le coût de réflexion",
      "Peut inclure une logique de transformation (ex : concaténer Nom + Prénom)",
      "Est inutile si les entités correspondent 1:1 à la base"
    ],
    "correctAnswer": 1,
    "part": 3
  },
  {
    "id": 182,
    "question": "Concernant la cohérence transactionnelle entre Command et Query :",
    "options": [
      "Une Command doit être transactionnelle (atomicité garantie)",
      "Une Query peut ouvrir une transaction pour lecture isolée",
      "On évite que les Query et Command partagent le même DbContext",
      "Les Handlers Command peuvent injecter un IUnitOfWork pour contrôler la persistance",
      "Les transactions doivent être gérées dans les contrôleurs"
    ],
    "correctAnswer": 0,
    "part": 3
  }
]