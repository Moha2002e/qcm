1.	Entity Framework est principalement :
A. Un langage de base de donn√©es
B. Un ORM (Object-Relational Mapper)
C. Un framework de logging
D. Une extension de LINQ
E. Une biblioth√®que pour Blazor
________________________________________
2.	L‚Äôapproche Code-First consiste √† :
A. Cr√©er d‚Äôabord la base de donn√©es et g√©n√©rer le code ensuite
B. Cr√©er les classes C# avant la base de donn√©es
C. Utiliser un diagramme EDMX
D. Cr√©er un script SQL avant les entit√©s
E. √âviter les migrations
________________________________________
3.	Quelle classe repr√©sente une session avec la base de donn√©es dans EF Core ?
A. DbSet
B. DbConnection
C. DbContext
D. DatabaseContext
E. ContextService
________________________________________
4.	Un DbSet<Student> repr√©sente :
A. Une collection d‚Äôentit√©s Student mapp√©e √† une table
B. Une seule instance de Student
C. Un script SQL de migration
D. Une cl√© √©trang√®re
E. Un logger d‚Äôex√©cution
________________________________________
5.	Par d√©faut, EF Core suit les changements sur les entit√©s gr√¢ce √† :
A. L‚ÄôAPI LINQ
B. Le Change Tracker
C. Le Migration Builder
D. Le Mapperly
E. L‚ÄôEntityStateManager
________________________________________
6.	Dans EF Core, quelle m√©thode enregistre les modifications dans la base ?
A. context.Submit()
B. context.SaveChangeAsync()
C. context.SaveChanges()
D. context.Persist()
E. context.Commit()
________________________________________
7.	Les propri√©t√©s d‚Äôune entit√© mapp√©es √† des colonnes simples sont appel√©es :
A. Propri√©t√©s scalaires
B. Propri√©t√©s de navigation
C. Propri√©t√©s virtuelles
D. Propri√©t√©s abstraites
E. Propri√©t√©s persist√©es









________________________________________
8.	Le code suivant illustre une relation :
public class Student {
   public Grade Grade { get; set; }
}
Quel type de relation ?
A. One-to-Many 
B. One-to-One
C. Many-to-Many
D. Aucun lien
E. Un lien nullable sans cl√©
________________________________________
9.	L‚Äôattribut [Key] en EF Core :
A. Supprime la cl√© primaire
B. Indique la propri√©t√© servant de cl√© primaire
C. Configure un index
D. Marque la propri√©t√© comme obligatoire
E. Sp√©cifie la taille maximale
________________________________________
10.	Comment rendre une propri√©t√© non mapp√©e en base de donn√©es ?Quelles approches permettent d'exclure une propri√©t√© du mapping en base de donn√©es ?
A. [NotMapped]
B. modelBuilder.Entity<Student>().Ignore(s => s.FullName)
C. [Ignore]
D. modelBuilder.Entity<Student>().Property(s => s.FullName).HasColumnName(null)
E. [DatabaseGenerated(DatabaseGeneratedOption.None)]
________________________________________
11.	La m√©thode OnModelCreating d‚Äôun DbContext est utilis√©e pour :
A. Configurer la connexion √† SQL Server
B. Configurer les entit√©s via Fluent API
C. Enregistrer les donn√©es
D. Supprimer la base de donn√©es
E. Charger les entit√©s
________________________________________
12.	Dans la configuration Fluent API, quel code configure la table ?
modelBuilder.Entity<Student>()
            .ToTable("StudentInfo");
A. D√©clare une entit√©
B. Mappe l‚Äôentit√© √† une table SQL sp√©cifique
C. Ajoute l‚Äôentit√©
D. Configure une relation
E. Configure une table
________________________________________
13.	Pour configurer une colonne auto-incr√©ment√©e avec FluentApi, quelle(s) approche(s) est/sont valide(s) ?
A. [DatabaseGenerated(DatabaseGeneratedOption.Identity)]
B. modelBuilder.Entity<User>().Property(u => u.Id).ValueGeneratedOnAdd()
C. [Key] suffit pour un int/long 
D. modelBuilder.Entity<User>().Property(u => u.Id).UseIdentityColumn()
E. modelBuilder.Entity<User>().Key(u => u.Id).UseIdentityColumn()
________________________________________
14.	Dans EF Core, Include() est utilis√© pour :
A. Charger les entit√©s avec lazy loading
B. Charger explicitement les entit√©s li√©es (eager loading)
C. Supprimer une relation
D. Ajouter une migration
E. Mapper une cl√© √©trang√®re
________________________________________
15.	Le code suivant :
context.Students.Remove(student);
context.SaveChanges();
fait quoi ?
A. Modifie la ligne
B. Supprime la ligne correspondante en base
C. D√©tache l‚Äôentit√© du contexte
D. Ajoute un √©tudiant
E. Vide la table
________________________________________
16.	Le ChangeTracker g√®re les √©tats suivants, sauf :
A. Added
B. Modified
C. Deleted
D. Created
E. Unchang

17.	Pour une relation Many-to-Many, EF Core 9 recommande :
A. Cr√©er manuellement les cl√©s √©trang√®res
B. Utiliser .UsingEntity<Jointure>() dans Fluent API
C. Utiliser [ManyToMany]
D. Cr√©er une seule propri√©t√© virtuelle
E. Mapper les deux c√¥t√©s sans jointure
________________________________________
18.	La suppression en cascade (Cascade Delete) :
A. Supprime toutes les tables
B. Supprime les enfants quand le parent est supprim√©
C. Emp√™che la suppression
D. Efface la base de donn√©es enti√®re
E. N√©cessite WillCascadeOnDelete(false) pour l‚Äôactiver
________________________________________
19.	Pour d√©sactiver la suppression en cascade dans Fluent API :
modelBuilder.Entity<Grade>()
    .HasMany(g => g.Students)
    .WithOne()
    .OnDelete(DeleteBehavior.Restrict);
A. Active le delete
B. Ignore les relations
C. Emp√™che la suppression du parent s‚Äôil a des enfants
D. Supprime les enfants
E. Clone la relation
________________________________________
20.	Une migration EF Core sert √† :
A. G√©n√©rer des seeders
B. Cr√©er ou modifier le sch√©ma de base de donn√©es
C. Supprimer les entit√©s
D. Synchroniser le mod√®le et la base de donn√©es
E. Synchroniser la base de donn√©es et le mod√®le
________________________________________
21.	Commande pour cr√©er une migration via CLI :
A. dotnet ef add
B. dotnet ef create migration
C. dotnet ef migrations add NomMigration
D. add-migration
E. update-database
________________________________________
22.	Commande pour appliquer une migration :
A. dotnet ef database update
B. dotnet ef run migration
C. add-migration
D. update-database
E. context.apply()

23.	context.Database.EnsureCreated() :
A. Met √† jour la DB
B. Cr√©e la base sans gestion de migration
C. Supprime la base
D. Cr√©e une migration automatique
E. Installe EF Core
________________________________________
24.	Dans EF Core, ExecuteUpdateAsync :
A. Met √† jour plusieurs lignes directement en SQL
B. Supprime plusieurs lignes
C. Ajoute un ensemble d‚Äôentit√©s
D. Met √† jour une seule entit√©
E. N‚Äôexiste pas
________________________________________
25.	Le Scaffold-DbContext sert √† :
A. G√©n√©rer le mod√®le √† partir d‚Äôun sch√©ma existant 
B. Supprimer des migrations
C. Ajouter des donn√©es par d√©faut
D. Mettre √† jour un mod√®le d‚Äôentit√©
E. Mettre √† jour un snapshot
________________________________________
26.	Les fournisseurs EF Core permettent de :
A. G√©rer les relations entre entit√©s
B. Changer de moteur de base de donn√©es (SQL Server, PostgreSQL, etc.)
C. Configurer les entit√©s
D. Cr√©er des migrations
E. S√©rialiser les entit√©s
________________________________________
27.	Exemple de code pour requ√™ter avec LINQ :
var result = context.Students
    .Where(s => s.Age > 18)
    .Include(s => s.Enrollments)
        .ThenInclude(e => e.Course)
    .AsNoTracking()
    .OrderBy(s => s.Name)
    .Select(s => new {
        s.Name,
        CourseCount = s.Enrollments.Count(),
        Courses = s.Enrollments.Select(e => e.Course.Title)
    }).ToList();
R√©sultat :
A. Une liste d'objets anonymes avec Name, CourseCount et Courses, sans tracking, tri√©e par nom
B. Une exception car Select() apr√®s Include() ignore les donn√©es charg√©es par Include
C. Un r√©sultat identique m√™me si on retire Include() et ThenInclude() car Select() charge automatiquement les relations n√©cessaires
D. Une requ√™te SQL avec LEFT JOIN sur Enrollments et Courses, puis une projection c√¥t√© client
E. Une exception car AsNoTracking() et Include() sont incompatibles


28.	Le mot cl√© virtual sur une propri√©t√© de navigation permet :
A. D‚Äôemp√™cher la s√©rialisation
B. Le lazy loading
C. Le mapping manuel
D. Le changement d‚Äô√©tat
E. L‚Äôimmuabilit√©
________________________________________
29.	Quel namespace contient DbContext ?
A. System.Data
B. Microsoft.EntityFrameworkCore
C. Microsoft.Data.SqlClient
D. System.Linq
E. EFCore.Context
________________________________________
30.	Fluent API et Data Annotations :
A. S‚Äôexcluent mutuellement
B. Peuvent √™tre combin√©s, Fluent API a priorit√©
C. Ne peuvent pas coexister
D. Peuvent √™tre combin√©s, Data Annotations a priorit√©
E. Servent au seeding
________________________________________
31.	Dans un DbContext, la m√©thode OnConfiguring :
A. Configure la cha√Æne de connexion
B. Configure les relations
C. G√®re les migrations
D. Enregistre les logs
E. Ajoute les seeds
________________________________________
32.	L‚Äô√©tat Detached d‚Äôune entit√© signifie :
A. Non suivie par le contexte
B. Supprim√©e de la base
C. Ajout√©e √† la base
D. Non persist√©e mais suivie
E. Synonyme de Deleted
________________________________________
33.	context.Entry(entity).State = EntityState.Modified;
A. Force EF √† marquer une entit√© comme modifi√©e
B. D√©tache l‚Äôentit√©
C. Supprime l‚Äôentit√©
D. Ajoute la cl√© √©trang√®re
E. Sauvegarde l‚Äôentit√©

34.	Pour injecter un DbContext dans ASP.NET Core :
A. builder.Services.AddScoped<MyContext>()
B. builder.Services.AddDbContext<MyContext>()
C. builder.AddDb()
D. services.UseSqlServer()
E. builder.UseEFContext()
________________________________________
35.	Les migrations EF Core sont stock√©es dans :
A. bin/Debug
B. Database/Migrations
C. Le dossier Migrations du projet
D. %appdata%
E. Le fichier appsettings.json

________________________________________
36.	Une Navigation Property de collection :
A. Mappe une seule entit√©
B. Repr√©sente une liste d‚Äôentit√©s li√©es
C. Est obligatoire
D. Est One-To-Many
E. Sert uniquement aux Many-to-Many
________________________________________
37.	EF Core g√®re les transactions :
A. Automatiquement sur SaveChanges()
B. Uniquement manuellement
C. Jamais
D. Avec ctx.Database.BeginTransactionAsync & ctx.Database.Commit/Rollback
E. Avec [Transactional]
________________________________________
38.	L‚Äôinstruction :
context.Attach(entity);
A. Attache une entit√© existante au contexte sans modification
B. Attache une entit√© existante
C. Ajoute une entit√©
D. Ajoute une entit√© avec modification
E. Ne suis pas l‚Äôentit√© dans le change tracker 
________________________________________
39.	IEntityTypeConfiguration<T> sert √† :
A. Configurer l‚Äôinjection de d√©pendances
B. D√©placer la configuration Fluent API dans une classe d√©di√©e
C. Configurer les entit√©s
D. G√©n√©rer la DB
E. D√©couple les configurations du DB contexte

40.	odelBuilder.ApplyConfigurationsFromAssembly(...) :
A. Applique les migrations
B. Applique automatiquement toutes les configurations d‚Äôentit√©s dans l‚Äôassembly
C. Compile la base de donn√©es
D. Sauvegarde les entit√©s
E. Cr√©e un contexte
________________________________________
41.	ASP.NET Core est :
A. Un framework uniquement Windows
B. Multiplateforme et open-source
C. Bas√© sur IIS exclusivement
D. Sans injection de d√©pendances
E. D√©di√© √† Blazor uniquement
________________________________________
42.	Le point d‚Äôentr√©e d‚Äôune application API est :
A. Startup.cs
B. Program.cs
C. MainController.cs
D. AppConfig.cs
E. ApiEntry.cs
________________________________________
43.	Une API minimaliste :
A. N√©cessite ControllerBase
B. Utilise app.MapGet(...) ou app.MapPost(...)
C. app.Controllers.Get ou app.Controllers.Post
D. Ne peut pas retourner JSON
E. N√©cessite MVC
________________________________________
44.	Un contr√¥leur Web API h√©rite g√©n√©ralement de :
A. Controller
B. ControllerBase
C. BaseController
D. WebController
E. MvcBase
________________________________________
45.	Attribut pour une route GET :
A. [HttpPost]
B. [Route("GET")]
C. [HttpGet]
D. [Verb("Get")]
E. [Get]

46.	M√©thode CreatedAtAction(...) retourne un code HTTP:
A. 201 Created
B. 200 OK
C. 404 NotFound
D. 204 NoContent
E. 400 BadRequest
________________________________________
47.	ActionResult<T> combine :
A. Une Action par d√©faut + R√©sultat
B. Typage fort + flexibilit√© des statuts de r√©ponse
C. T + JSON
D. Response only 
E. Middleware + Result
________________________________________
48.	Le code suivant :
return NotFound();
Renvoie :
A. 500
B. 200
C. 404
D. 201
E. 204
________________________________________
49.	Le pipeline d‚Äôex√©cution ASP.NET Core est une cha√Æne de :
A. Routes
B. Middlewares
C. Controllers 
D. Filtres uniquement
E. Assemblies
________________________________________
50.	builder.Services.AddControllers() :
A. Active le routage bas√© sur les contr√¥leurs
B. Enregistre les contr√¥leurs dans le conteneur DI
C. D√©marre la base de donn√©es
D. Ajoute Swagger
E. Cr√©e la route API
________________________________________
51.	app.MapControllers() :
A. Active le routage bas√© sur les contr√¥leurs
B. Enregistre les contr√¥leurs dans le conteneur DI
C. Configure Open Api
D. Active l‚ÄôAPI
E. Initialise Serilog

52.	Dans appsettings.json, les cha√Ænes de connexion se trouvent sous :
A. "DbContext"
B. "EF"
C. "ConnectionStrings"
D. "ToDoConnectionStrings" pour un DbContext ¬´ ToDo ¬ª
E. "DatabaseConfig"
‚û° R√©ponse : C
________________________________________
53.	L‚Äôattribut [ApiController] permet :
A. D‚Äôactiver Swagger
B. La validation automatique des mod√®les et le binding intelligent
C. Le routing par convention
D. Le mapping JSON manuel
E. L‚Äôinjection de d√©pendance
________________________________________
54.	Quelle m√©thode du contr√¥leur retourne 204 NoContent ?
A. return Ok()
B. return Empty()
C. return NoContent()
D. return None() 
E.return null
________________________________________
55.	Dans le routage :
[HttpGet("{id:int}")]
signifie :
A. Param√®tre optionnel
B. Param√®tre id de type entier obligatoire
C. Param√®tre id de type entier
D. Identifiant global
E. Param√®tre facultatif
________________________________________
56.	Swagger et Scalar sont :
A. Des UIs de visualisation et test d‚ÄôAPI OpenAPI
B. Des frameworks REST
C. Des serveurs SQL
D. Des ORM
E. Des middlewares d‚Äôauthentification
________________________________________
57.	Le logging natif de Microsoft utilise :
A. ILogger
B. Log4Net
C. EventLog
D. TraceSource
E. Serilog

58.	Serilog est :
A. Un ORM
B. Un moteur SQL
C. Un framework de logging structur√©
D. Une UI Swagger
E. Un container DI




________________________________________
59.	Pour activer Serilog dans ASP.NET Core :
A. app.UseLogger()
B. app.UseSerilogRequestLogging()
C. builder.AddSerilog()
D. services.UseSerilog()
E. logger.Enable()
________________________________________
60.	AddSerilog(...) permet :
A. D‚Äôajouter un middleware
B. De lire la configuration Serilog depuis appsettings.json
C. De configurer les endpoints
D. D‚Äôinitialiser EF Core
E. De cr√©er un fichier log manuellement
________________________________________
61.	Serilog peut √©crire vers :
A. Console
B. Fichier
C. ElasticSearch
D. EventLog
E. Toutes les r√©ponses
________________________________________
62.	ILogger<WeatherService> inject√© dans un service permet :
A. D‚Äôenvoyer des mails
B. De tracer les √©v√©nements du service dans les logs
C. D‚Äôacc√©der √† EF Core
D. De g√©rer les erreurs
E. D‚Äô√©crire des fichiers CSV
________________________________________
63.	Le middleware app.UseDeveloperExceptionPage() :
A. Affiche les d√©tails d‚Äôerreurs en mode d√©veloppement
B. Cache les exceptions
C. Logue les erreurs dans Serilog
D. Relance le serveur
E. Supprime la base

64.	AddOpenApi() sert √† :
A. Ajouter EF Core
B. G√©n√©rer le document openapi/v1.json
C. Configurer les routes
D. Activer Scalar
E. Ajouter Swagger
________________________________________
65.	Les m√©thodes HTTP principales utilis√©es dans REST :
A. Ping, Call, Update, Erase
B. GET, POST, PUT, DELETE
C. Fetch, Push, Merge, Clear
D. Query, Modify, Create, Drop
E. Sync, Upload, Remove, Refresh
________________________________________
66.	app.Run(); :
A. Cr√©e la base
B. D√©marre le serveur web
C. Compile l‚Äôapplication
D. Arr√™te la base
E. Logue les erreurs
________________________________________
67.	Les filtres API globaux :
A. S‚Äôappliquent √† un seul contr√¥leur
B. Affectent toutes les requ√™tes (log, auth, validation)
C. Ne peuvent √™tre configur√©s
D. Existent seulement en MVC
E. Ne sont pas support√©s
________________________________________
68.	Le mot cl√© async sur une m√©thode API permet :
A. De g√©rer les appels asynchrones (I/O non bloquants)
B. De forcer la synchronicit√©
C. De d√©sactiver les exceptions
D. D‚Äôactiver LINQ
E. D‚Äôutiliser EF Core
________________________________________
69.	Le r√©sultat Results.Ok(obj) appartient √† :
A. IActionResult
B. HttpResults (Minimal APIs)
C. ActionResult<T>
D. ResponseBody
E. IResponse

70.	Code pour retourner 404 avec Minimal API :
return Results.NotFound();
A. Invalide
B. N√©cessite MVC
C. Correct
D. Retourne 500
E. Retourne 204
________________________________________
71.	Une bonne pratique pour les erreurs API est :
A. try/catch dans chaque action
B. Utiliser un middleware d‚Äôerreur global
C. Ignorer les exceptions
D. Les cacher avec NoContent
E. try/catch au niveaudu program.cs
________________________________________
72.	Les types de retour conseill√©s pour API modernes :
A. void
B. HttpResponse
C. ActionResult
D. ActionResult<T>
E. Task<object>
________________________________________
73.	Dans le cycle API :
Requ√™te ‚Üí Routing ‚Üí Contr√¥leur ‚Üí Action ‚Üí R√©ponse
Quelle √©tape ex√©cute la logique m√©tier ?
A. Routing
B. Middleware
C. Action
D. Filter
E. Logger






________________________________________
74.	Pour initialiser la base au d√©marrage :
A. Cr√©er un scope, puis appeler context.Database.EnsureCreated()
B. Lancer dotnet ef database update
C. Utiliser OnModelCreating
D. Ajouter [InitDatabase]
E. Modifier appsettings.json
________________________________________
75.	Un service inject√© avec AddScoped vit :
A. Pendant tout le cycle de vie de l‚Äôapplication
B. Le temps d‚Äôune requ√™te HTTP
C. Jusqu‚Äô√† un red√©marrage
D. Jusqu‚Äô√† l‚Äôappel Dispose()
E. 5 minutes

76.	Les niveaux de logs par ordre croissant sont :
A. Critical < Debug < Error < Information
B. Debug < Warning < Critical < Trace
C. Trace < Debug < Information < Warning < Error < Critical
D. Warning < Trace < Error
E. Debug < Trace < Warning < Info
________________________________________
77.	Le but de la Clean Architecture est :
A. S√©parer les responsabilit√©s et limiter les d√©pendances
B. D√©coupler les couches
C. Coupler domaine et infrastructure
D. √âviter les DTO
E. Am√©liorer la maintenabilit√© du code
________________________________________
78.	Les 4 couches principales sont :
A. Controler, Application, Entity, Infrastructure
B. Presentation, Application, Domain, Infrastructure
C. Controler, Repository, Service, Model
D. Presentation, Application, Model, Repository
E. ORM, DTO, Controller, Logger
________________________________________
79.	Le dossier Domain contient :
A. Les DTO
B. Les contr√¥leurs
C. Les entit√©s m√©tier et la logique pure
D. Les fichiers de migration
E. Les vues
________________________________________
80.	Un Repository :
A. Encapsule l‚Äôacc√®s aux donn√©es
B. Appelle les contr√¥leurs
C. G√®re le routage
D. Supprime les services
E. Configure EF
________________________________________
81.	Un Service de la couche Application :
A. D√©finit le sch√©ma SQL
B. Orchestre les r√®gles m√©tier (use cases)
C. G√®re la configuration
D. S√©rialise les logs
E. √âcrit dans Serilog
‚ÄÉ
82.	Un Mapper (Mapperly, AutoMapper‚Ä¶) :
A. Cr√©e les migrations
B. Transforme les entit√©s en DTO et inversement
C. Cr√©e le DbContext
D. Sauvegarde les donn√©es
E. Lit le fichier appsettings
________________________________________
83.	CQRS signifie :
A. Command Query Responsibility Segregation
B. Core Query Runtime System
C. Concurrent Query Routing Service
D. Command Queue Remote System
E. Control Query Reset Segment
________________________________________
84.	Une Command :
A. Modifie l‚Äô√©tat du syst√®me (Create, Update, Delete)
B. R√©cup√®re des donn√©es
C. Fait un SELECT
D. Supprime les logs
E. Configure l‚ÄôAPI
________________________________________
85.	Une Query :
A. Modifie les donn√©es
B. Lit des donn√©es sans effet de bord
C. Supprime des entit√©s
D. G√®re les logs
E. D√©clenche les migrations
________________________________________
86.	Les DTO servent √† :
A. Transf√©rer des fichiers
B. Transf√©rer des donn√©es entre couches 
C. G√©rer les logs
D. Cr√©er la DB
E. Limiter les donn√©es envoy√©es au client
________________________________________




















üß† Termes √† d√©finir (25 essentiels)
1.	Entity Framework Core
2.	DbContext
3.	DbSet
4.	Migration
5.	Fluent API
6.	Data Annotation
7.	LINQ
8.	EntityState
9.	Cascade Delete
10.	Scaffold-DbContext
11.	Connection String
12.	Middleware
13.	Dependency Injection (DI)
14.	ActionResult
15.	Swagger / OpenAPI
16.	Serilog
17.	Clean Architecture
18.	Domain Layer
19.	Application Layer
20.	Infrastructure Layer
21.	Repository Pattern
22.	Service Layer
23.	DTO (Data Transfer Object)
24.	Mapperly
25.	CQRS (Command Query Responsibility Segregation)

1.	Entity Framework Core ‚Äì ORM pour g√©rer la base de donn√©es depuis du code C#.
2.	DbContext ‚Äì Classe repr√©sentant la session avec la base et les entit√©s.
3.	DbSet ‚Äì Collection d‚Äôentit√©s d‚Äôun type sp√©cifique dans le DbContext.
4.	Migration ‚Äì Fichier qui modifie ou cr√©e le sch√©ma de la base.
5.	Fluent API ‚Äì Configuration des entit√©s via code C# plut√¥t qu‚Äôattributs.
6.	Data Annotation ‚Äì Attributs C# pour configurer les entit√©s et colonnes.
7.	LINQ ‚Äì Syntaxe C# pour interroger collections et bases de donn√©es.
8.	EntityState ‚Äì √âtat d‚Äôune entit√© suivi par EF Core (Added, Modified, Deleted‚Ä¶).
9.	Cascade Delete ‚Äì Supprime automatiquement les entit√©s enfants lors de la suppression du parent.
10.	Scaffold-DbContext ‚Äì G√©n√®re le mod√®le EF Core √† partir d‚Äôune base existante.
11.	Connection String ‚Äì Cha√Æne d√©finissant comment se connecter √† la base de donn√©es.
12.	Middleware ‚Äì Composant de traitement d‚Äôune requ√™te dans le pipeline ASP.NET Core.
13.	Dependency Injection (DI) ‚Äì Injection automatique des d√©pendances dans les classes.
14.	ActionResult ‚Äì Type de retour d‚Äôune action contr√¥leur combinant donn√©es et statut HTTP.
15.	Swagger / OpenAPI ‚Äì Outils pour documenter et tester les API REST.
16.	Serilog ‚Äì Framework de logging structur√© pour applications .NET.
17.	Clean Architecture ‚Äì Organisation du code en couches s√©parant responsabilit√©s et d√©pendances.
18.	Domain Layer ‚Äì Contient les entit√©s m√©tier et la logique pure.
19.	Application Layer ‚Äì Contient la logique d‚Äôorchestration et les cas d‚Äôusage.
20.	Infrastructure Layer ‚Äì G√®re l‚Äôacc√®s aux donn√©es, API externes et services techniques.
21.	Repository Pattern ‚Äì Classe qui encapsule l‚Äôacc√®s aux donn√©es pour une entit√©.
22.	Service Layer ‚Äì Contient la logique m√©tier r√©utilisable par l‚Äôapplication.
23.	DTO (Data Transfer Object) ‚Äì Objet pour transf√©rer uniquement les donn√©es n√©cessaires entre couches.
24.	Mapperly ‚Äì Outil pour convertir automatiquement entit√©s ‚Üî DTO.
25.	CQRS ‚Äì S√©pare les op√©rations de lecture (Query) et d‚Äô√©criture (Command) sur les donn√©es.




________________________________________
1.Lorsqu‚Äôune entit√© est lue via un DbContext, puis modifi√©e sans appel √† Attach ou Update, EF Core :
A. L√®ve une exception de suivi incoh√©rent
B. Ignore la modification
C. La d√©tecte automatiquement si elle est suivie par le ChangeTracker
D. Modifie toutes les lignes correspondantes
E. N√©cessite explicitement context.Entry(entity).State = Modified
________________________________________
2.Le comportement de context.Attach(entity) d√©pend de :
A. Si la cl√© primaire est renseign√©e ou non
B. L‚Äô√©tat courant de l‚Äôentit√©
C. Les entit√©s enfants rattach√©es
D. Le mode de suivi du contexte
E. Toutes ces r√©ponses
________________________________________
3.Lors d‚Äôun SaveChanges(), EF Core :
A. G√©n√®re un script SQL et l‚Äôex√©cute sans transaction
B. Utilise une transaction implicite regroupant les modifications suivies
C. Valide chaque entit√© individuellement
D. Envoie un batch par propri√©t√© modifi√©e
E. D√©pend du provider de base de donn√©es uniquement
________________________________________
4.Si deux DbContext diff√©rents chargent la m√™me entit√© et que chacun la modifie avant SaveChanges(), EF :
A. √âcrase silencieusement le dernier enregistrement
B. Lance une exception d‚Äôacc√®s concurrent
C. Ne d√©tecte pas le conflit sauf si une colonne de concurrence est configur√©e
D. Synchronise automatiquement les changements
E. Fusionne les versions
________________________________________
5.Quelle est la diff√©rence entre Add() et Attach() ?
A. Attach cr√©e une nouvelle entit√©, Add la r√©utilise
B. Add attache mais ne change pas l‚Äô√©tat
C. Add marque l‚Äôentit√© comme Added, Attach comme Unchanged
D. Elles sont √©quivalentes
E. Attach ne fonctionne que sur les entit√©s enfants
________________________________________
6.Un DbContext ne doit g√©n√©ralement pas √™tre enregistr√© en Singleton car :
A. Il ne g√®re pas le multithreading
B. Il ne supporte pas les transactions longues
C. Son ChangeTracker accumule les entit√©s
D. Il est con√ßu pour une dur√©e de vie courte (Scoped)
E. Toutes ces r√©ponses
________________________________________
7.Quelle instruction cr√©e r√©ellement la table en base dans une approche Code-First ?
A. EnsureCreated()
B. Add-Migration
C. Update-Database
D. Migrate()
E. context.SaveChanges()
________________________________________
8.Les conventions par d√©faut d‚ÄôEF Core :
A. Imposent les noms de colonnes en majuscules
B. Ne peuvent pas √™tre surcharg√©es
C. Peuvent √™tre remplac√©es via Fluent API ou annotations
D. Sont d√©sactiv√©es par d√©faut
E. N‚Äôagissent que sur les cl√©s √©trang√®res

9.Lorsqu‚Äôun DbContext suit deux entit√©s ayant la m√™me cl√© primaire :
A. EF met √† jour la plus r√©cente
B. EF cr√©e deux lignes
C. Une exception InvalidOperationException est lev√©e
D. Les deux sont fusionn√©es
E. Rien ne se passe
________________________________________
10.Le ChangeTracker.AutoDetectChangesEnabled d√©sactiv√© permet :
A. D‚Äôemp√™cher la d√©tection de modifications automatiques
B. D‚Äôoptimiser les op√©rations massives (batch)
C. De d√©sactiver la persistance
D. De supprimer le contexte
E. De rendre SaveChanges() instantan√©
________________________________________
11.La suppression en cascade implicite s‚Äôapplique :
A. √Ä toutes les relations
B. Seulement si la relation est Required (non nullable)
C. Seulement si DeleteBehavior.Cascade est explicite
D. Jamais, par s√©curit√©
E. Pour toutes les entit√©s enfants
________________________________________
12.Quelle est la sortie SQL la plus probable du code suivant :
context.Students.Where(s => s.Grade.GradeName == "A");
A. Un JOIN avec la table Grade
B. Une sous-requ√™te
C. Une requ√™te cart√©sienne
D. Un SELECT sur Students uniquement
E. Une exception de mapping
________________________________________
13.Dans un mod√®le Many-to-Many sans entit√© de jointure explicite, EF Core :
A. Cr√©e une entit√© Join implicite
B. Cr√©e une table de liaison sans classe d√©di√©e
C. Requiert [ForeignKey] manuelle
D. N√©cessite une configuration One-to-Many double
E. Ne supporte pas ce sc√©nario
________________________________________
14.Quelle est la cons√©quence de context.ChangeTracker.Clear() ?
A. Supprime la base
B. D√©tache toutes les entit√©s suivies
C. Vide les tables
D. Enregistre les changements
E. Met les entit√©s √† Unchanged
________________________________________
15.Une migration EF Core contient :
A. Un snapshot du mod√®le + le code SQL des modifications
B. Des m√©tadonn√©es JSON
C. Deux classes : une Migration et un ModelSnapshot
D. Des scripts SQL ex√©cutables
E. Des triggers automatiques
________________________________________
16.Si Database.EnsureCreated() est utilis√© avant une migration :
A. La migration suivante l‚Äô√©crase
B. Les migrations ne pourront plus √™tre appliqu√©es sans supprimer la DB
C. Les migrations s‚Äôempilent
D. EF fusionne les deux sch√©mas
E. Rien ne change

17.Le code :
context.Entry(student).State = EntityState.Detached;
A. Sauvegarde l‚Äôentit√©
B. D√©tache l‚Äôentit√© du contexte, elle n‚Äôest plus suivie
C. Supprime la ligne en DB
D. Rattache une entit√©
E. Fait un rollback
________________________________________
18.LINQ to Entities :
A. Utilise des it√©rateurs C#
B. Ex√©cute la requ√™te c√¥t√© client
C. Traduit l‚Äôexpression en SQL ex√©cut√© c√¥t√© serveur
D. Cr√©e un cache m√©moire
E. Est identique √† LINQ to Objects
________________________________________
19.FirstOrDefault() sur un IQueryable EF Core :
A. Charge tout le dataset
B. Ex√©cute imm√©diatement la requ√™te SQL avec TOP 1
C. Retourne un proxy non charg√©
D. Retourne null si rien n‚Äôest trouv√©
E. Cr√©e une collection vide si rien n‚Äôest trouv√©
________________________________________
20.La commande dotnet ef migrations add Init --context AppContext :
A. Ajoute une migration en pr√©cisant la classe de contexte
B. Cr√©e la base
C. Liste les migrations
D. Ajoute une premi√®re migration
E. Applique la migration
________________________________________
21.Quelle diff√©rence principale existe entre AsEnumerable() et AsNoTracking() sur une requ√™te EF Core ?
A. AsEnumerable() ex√©cute la requ√™te en m√©moire
B. AsNoTracking() d√©sactive la d√©tection des modifications
C. AsEnumerable() conserve le tracking
D. AsNoTracking() est plus l√©ger pour la lecture seule
E. Toutes ces r√©ponses sont correctes
________________________________________
22.Le code suivant :
var s = context.Students.First();
s.Name = "Karl";
context.SaveChanges();
Que fait EF Core ?
A. N‚Äôenregistre pas le changement sans Update()
B. D√©tecte la modification et ex√©cute un UPDATE SQL
C. Cr√©e un nouvel enregistrement
D. D√©clenche une exception si la table est vide
E. Met la ligne √† Unchanged
________________________________________
23.Lorsqu‚Äôune propri√©t√© Navigation est marqu√©e virtual, EF Core :
A. Cr√©e un proxy dynamique pour le lazy loading
B. Peut diff√©rer le chargement des donn√©es li√©es
C. N√©cessite Microsoft.EntityFrameworkCore.Proxies
D. D√©sactive le tracking
E. Ne supporte pas le Include()

‚ÄÉ
24.L‚Äôoption UseQueryTrackingBehavior(QueryTrackingBehavior.NoTracking) configur√©e globalement :
A. D√©sactive les transactions
B. D√©sactive par d√©faut le suivi des entit√©s retourn√©es
C. Rend la lecture plus performante
D. Bloque SaveChanges()
E. N√©cessite un rechargement manuel pour modifier
________________________________________
25.Quel est le r√©sultat de ce code ?
context.Students.Where(s => s.Id == 1).FirstOrDefault();
context.Students.Where(s => s.Id == 1).FirstOrDefault();
A. Une seule requ√™te SQL est ex√©cut√©e gr√¢ce au cache EF
B. Deux requ√™tes SQL sont ex√©cut√©es, pas de cache de requ√™te par d√©faut
C. La seconde l√®ve une exception de suivi
D. Une transaction est ouverte
E. Le premier r√©sultat reste en m√©moire partag√©e
________________________________________
26.Les Shadow Properties dans EF Core :
A. Sont des propri√©t√©s non d√©clar√©es dans la classe C# mais suivies par EF
B. Permettent de stocker des m√©tadonn√©es internes (FK, timestamps, etc.)
C. Ne sont accessibles que via Entry().Property("Nom")
D. Peuvent √™tre persist√©es en base
E. Toutes ces r√©ponses
________________________________________
27.Le type de suppression DeleteBehavior.ClientSetNull :
A. Supprime les enfants en base
B. Met √† null les FK en m√©moire, sans propager en DB avant SaveChanges()
C. D√©pend de la transaction
D. Supprime aussi le parent
E. D√©connecte le contexte
________________________________________
28.Les Owned Types :
A. Sont stock√©s dans la m√™me table que l‚Äôentit√© propri√©taire
B. Repr√©sentent des objets de valeur sans cl√© propre
C. Ne peuvent √™tre partag√©s entre entit√©s
D. N√©cessitent Fluent API
E. Toutes ces r√©ponses
________________________________________
29.Pour qu‚Äôune propri√©t√© DateCreated soit automatiquement remplie lors de l‚Äôinsertion :
A. [DatabaseGenerated(DatabaseGeneratedOption.Computed)]
B. [DefaultValue("getdate()")]
C. Configuration via Fluent API .HasDefaultValueSql("getutcdate()")
D. [Timestamp]
E. N√©cessite un trigger SQL
________________________________________
30.Les requ√™tes compos√©es sur IQueryable EF Core sont :
A. Ex√©cut√©es imm√©diatement
B. Construites en expression tree et traduites √† l‚Äôex√©cution (deferred execution)
C. Stock√©es en cache jusqu‚Äô√† ToList()
D. Ex√©cut√©es ligne par ligne
E. Converties en LINQ to Objects

‚ÄÉ
31.Le code suivant :
var stud = new Student { Id = 10, Name = "Karl" };
context.Update(stud);
Suppose que l‚Äô√©tudiant existe d√©j√†.
A. Marque l‚Äôentit√© comme Modified sans la lire
B. Charge la ligne depuis la base
C. L√®ve une exception s‚Äôil n‚Äôexiste pas
D. Supprime les relations
E. N√©cessite un SaveChanges() pour ex√©cuter le SQL
________________________________________
32.Quelle pratique est d√©conseill√©e pour les performances EF ?
A. Include() sur plusieurs niveaux de profondeur
B. ToList() avant Where()
C. Charger 10 000 entit√©s track√©es
D. Ex√©cuter SaveChanges() dans une boucle
E. Toutes ces pratiques sont d√©conseill√©es
________________________________________
33.Les cl√©s composites sont configur√©es via :
A. [Key("A","B")]
B. [CompositeKey]
C. modelBuilder.Entity<T>().HasKey(e => new { e.A, e.B })
D. AddCompositeKey()
E. Non support√© par EF
________________________________________
34.Le mode SingleOrDefault() :
A. L√®ve une exception si plus d‚Äôune correspondance existe
B. Retourne null si aucune entit√©
C. Peut charger plus lentement qu‚Äôun FirstOrDefault()
D. Combine filtrage + validation d‚Äôunicit√©
E. Ne peut pas √™tre traduit en SQL
________________________________________
35.Les Compiled Queries d‚ÄôEF Core servent √† :
A. Ex√©cuter du SQL brut
B. Pr√©compiler l‚Äôarbre d‚Äôexpression pour r√©utilisation (gain de perf)
C. Cr√©er des index
D. G√©n√©rer des migrations automatiques
E. Sauvegarder le contexte
________________________________________
36.Quel sc√©nario n√©cessite le TransactionScope ?
A. SaveChanges() standard
B. Modification de plusieurs contextes ou sources de donn√©es dans la m√™me transaction
C. Lazy Loading
D. Delete cascade
E. Mapping complexe
________________________________________
37.L‚Äôoption .UseLazyLoadingProxies() :
A. Est activ√©e par d√©faut
B. N√©cessite les propri√©t√©s virtual
C. Cr√©e des proxys dynamiques pour charger les donn√©es √† la demande
D. Affecte les performances
E. R√©ponses : B, C, D

‚ÄÉ
38.Quelle diff√©rence entre Find() et FirstOrDefault() ?
A. Find() cherche d‚Äôabord dans le cache du contexte avant la DB
B. Find() n√©cessite la cl√© primaire
C. FirstOrDefault() ex√©cute toujours une requ√™te SQL
D. Find() est plus rapide si l‚Äôentit√© est d√©j√† suivie
E. Toutes ces r√©ponses
________________________________________
39.Une migration contenant un renommage de colonne et un changement de type :
A. Est ex√©cut√©e en une seule commande SQL
B. Peut g√©n√©rer un DROP + CREATE selon le provider
C. Ne peut pas √™tre rollback√©e
D. N‚Äôest pas d√©tect√©e automatiquement
E. Supprime la contrainte FK associ√©e
________________________________________
40.Pour ins√©rer des donn√©es initiales conditionnelles :
A. [SeedData]
B. Utiliser HasData() dans OnModelCreating
C. Cr√©er une classe statique DbSeeder ex√©cut√©e au d√©marrage
D. Ajouter une migration sp√©ciale
E. Utiliser context.Database.Migrate()
________________________________________
42.Diff√©rence principale Middleware vs Filter en Web API :
A. Les filters s‚Äôex√©cutent avant le routing
B. Les middlewares enveloppent tout le pipeline, les filters ciblent contr√¥leurs/actions
C. Les filters ont acc√®s au ModelState et aux r√©sultats d‚Äôaction
D. Les middlewares ne peuvent pas court-circuiter la r√©ponse
E. Les middlewares peuvent s‚Äôappliquer aux fichiers statiques et endpoints non-API
________________________________________
43.En Minimal APIs, que renvoie le plus pr√©cis√©ment Results.NotFound() ?
A. ActionResult
B. IActionResult
C. Un IResult (impl√©mentation HttpResults)
D. ProblemDetails
E. HttpResponseMessage
________________________________________
44.Pour masquer la validation implicite d‚Äô[ApiController] et g√©rer toi-m√™me la r√©ponse :
A. Supprimer [ApiController]
B. D√©sactiver SuppressModelStateInvalidFilter
C. Utiliser [ValidateNever] sur le type
D. Intercepter via un ActionFilter et tester ModelState.IsValid
E. app.Services.DisableValidation()
________________________________________
45.Concernant ActionResult<T> :
A. Emp√™che de retourner NotFound()
B. Permet de retourner soit un T, soit un IActionResult
C. S√©rialise T et force 200 OK
D. Expose le type pour la doc OpenAPI plus pr√©cis√©ment qu‚Äôun IActionResult
E. N‚Äôest pas compatible avec async
________________________________________
46.[FromBody] vs [FromQuery] : comportement par d√©faut en API :
A. Les param√®tres simples viennent du body par d√©faut
B. Un seul param√®tre [FromBody] par action en JSON (par d√©faut)
C. Les param√®tres complexes (classe) viennent du body par d√©faut
D. Les param√®tres simples (string, int) viennent du body
E. Les param√®tres simples viennent de la query/route par d√©faut

‚ÄÉ
51.ILogger<T> : lequel est vrai ?
A. Les messages interpol√©s sont toujours structur√©s
B. Utiliser des ‚Äúmessage templates‚Äù logger.LogInformation("User {Id} ...", id) cr√©e des champs structur√©s
C. √âcrire des objets comme {@obj} n‚Äôest support√© que par STJ
D. ILogger n√©cessite Serilog
E. Le nom de cat√©gorie du log ‚Äúcategory name‚Äù est le nom de T par d√©faut
________________________________________
52.Serilog avec ASP.NET Core pour journaliser chaque requ√™te :
A. Ajouter UseLogging()
B. app.UseSerilogRequestLogging()
C. Logger uniquement en Production
D. Possibilit√© d‚Äôenrichir (ex: WithMachineName, FromLogContext) via config
E. Oblige le format JSON
________________________________________
53.Configurer Swagger/Scalar en .NET 9 :
A. builder.Services.AddOpenApi()
B. app.UseSwagger() obligatoire
C. app.MapOpenApi() pour exposer /openapi/v1.json
D. app.MapScalarApiReference() pour l‚ÄôUI Scalar
E. app.UseOpenApiUI()
________________________________________
56.CancellationToken dans une action :
A. Peut √™tre pass√© en param√®tre pour annuler un await db.ToListAsync(ct)
B. Inutile pour EF Core
C. D√©sactive le time-out
D. Est aliment√© par la fermeture de la connexion HTTP
E. N‚Äôest disponible qu‚Äôen Minimal API
________________________________________
57.Choisir la dur√©e de vie DI appropri√©e :
A. DbContext en Singleton pour r√©duire les allocations
B. HttpClient en Scoped par d√©faut
C. DbContext en Scoped (requ√™te)
D. Services stateless (Mapper, Validator) souvent en Transient
E. Caches/configuration (lecture) en Singleton
________________________________________
59.Pour valider un mod√®le d‚Äôentr√©e (DTO) avec des r√®gles avanc√©es :
A. [RegularExpression] uniquement
B. FluentValidation (librairie tierce) ou DataAnnotations
C. Cr√©er un ActionFilter de validation pour format unifi√© des erreurs
D. Valider le DTO dans le contr√¥leur 
E. ModelState est obsol√®te
________________________________________
63.Pagination propre en Web API :
A. Prendre tout puis paginer en m√©moire
B. Retourner des m√©tadonn√©es (page, size, total) dans des en-t√™tes ou un enveloppe JSON
C. Limiter pageSize max c√¥t√© serveur
D. Utiliser AsNoTracking pour les listes
E. Ignorer la stabilit√© d‚Äôordre
________________________________________
64.Minimal APIs vs Controllers :
A. Minimal = pas de filtres possible
B. Minimal expose des endpoints fonctionnels, l√©ger pour microservices
C. Controllers = filtres + conventions MVC + attributs riches
D. Minimal interdit DI
E. Minimal renvoie des IResult, contr√¥leur renvoie ActionResult<T>

‚ÄÉ
66.Global exception handling recommand√© :
A. try/catch dans chaque action
B. Middleware global + mapping ‚Üí ProblemDetails standard
C. Filtres d‚Äôexception uniquement
D. Rediriger vers /error en production
E. Journaliser (corr√©lation Id) + ne pas divulguer les d√©tails en prod
________________________________________
68.Routing : contraintes et noms :
A. [HttpGet("{id:int}")] contraint id √† un entier
B. Le nom d‚Äôune route (ex. :GetByName) doit √™tre unique quel que soit le contr√¥leur 
C. Les routes nomm√©es ne servent qu‚Äô√† la doc
D. Des param√®tres optionnels "{category?}" sont possibles
E. * capture un segment, ** plusieurs (catch-all)
________________________________________
69.Content negotiation :
A. Par d√©faut JSON via System.Text.Json
B. Accept: application/xml est toujours respect√© sans config
C. On peut ajouter un formatter XML
D. text/csv est pris en charge nativement
E. La n√©gociation peut renvoyer 406 si non support√© (si configur√©)
________________________________________
74.OpenAPI doc :
A. Toujours exposer /openapi/v1.json en prod sans auth
B. Prot√©ger l‚ÄôUI (Swagger/Scalar) en prod ou la d√©sactiver
C. D√©crire les sch√©mas, codes de retour, auth (OAuth2/Bearer)
D. G√©n√©rer automatiquement des clients sans configuration
E. MapOpenApi() supporte plusieurs versions
________________________________________
75.Performance ‚Äî anti-patterns courants :
A. Serializer synchro sur gros payloads
B. ToList() pr√©matur√© avant Where/Select
C. Logging verbeux au niveau Debug/Trace en prod
D. AsNoTracking() pour lecture seule
E. SaveChanges() dans une boucle au lieu de batch
________________________________________
77.HttpLoggingMiddleware :
A. Peut journaliser headers, requ√™te, r√©ponse
B. Toujours recommand√© en prod sans filtre
C. Risque de fuite de donn√©es sensibles si mal configur√©
D. Ne fonctionne pas avec HTTPS
E. Peut d√©grader la perf si on logge les bodies volumineux
________________________________________
79.DI circular dependency :
A. Peut provoquer des boucles d‚Äôinitialisation et exceptions
B. R√©solu automatiquement par le conteneur
C. Souvent signe d‚Äôun design √† refactorer
D. R√©solu en changeant toutes les dur√©es de vie en Singleton
E. Parfois corrig√© en introduisant des ports/interfaces plus fins
________________________________________
80.JSON patch / partial updates :
A. HttpPatch non support√©
B. Support√© uniquement via Newtonsoft
C. Valider les op√©rations patch et la s√©curit√© (chemins autoris√©s)
D. Toujours pr√©f√©rable √† PUT
E. Penser √† la concurrence (RowVersion)

81.La Clean Architecture vise avant tout √† :
A. R√©duire le couplage entre UI et donn√©es
B. Faire d√©pendre le code m√©tier uniquement d‚Äôabstractions
C. Isoler le domaine de toute technologie (framework, base, UI)
D. Utiliser CQRS obligatoirement
E. Faciliter le test unitaire et la maintenabilit√© dans le temps
________________________________________
82.Dans une architecture en couches proprement isol√©e :
A. La couche Presentation r√©f√©rence la couche Domain directement
B. La couche Application r√©f√©rence le Domain et expose des interfaces impl√©ment√©es dans Infrastructure
C. Infrastructure conna√Æt Application mais pas l‚Äôinverse
D. Les d√©pendances vont toujours du haut (UI) vers le bas (Domain)
E. Les DTO peuvent √™tre d√©finis dans Domain
________________________________________
83.Le pattern Repository permet :
A. De remplacer les requ√™tes SQL par LINQ
B. D‚Äôavoir un acc√®s direct au contexte EF
C. D‚Äôencapsuler la logique d‚Äôacc√®s aux donn√©es derri√®re une interface abstraite
D. De rendre les tests possibles avec des mocks ou bases InMemory
E. D‚Äôutiliser EF Core
________________________________________
84.Quel est le r√¥le d‚Äôun Service d‚Äôapplication dans la Clean Architecture ?
A. Orchestrer les r√®gles m√©tier entre plusieurs entit√©s et repositories
B. Remplacer le contr√¥leur
C. Coordonner le mapping entit√© ‚Üî DTO et d√©clencher des transactions
D. Impl√©menter la logique de validation HTTP
E. Ex√©cuter directement les requ√™tes SQL
________________________________________
85.Le Domain Layer devrait contenir :
A. Des entit√©s, des value objects, et les r√®gles m√©tier pures
B. Les classes de configuration EF
C. Les contr√¥leurs
D. Aucune d√©pendance vers Entity Framework ou ASP.NET Core
E. Les DTO d‚Äôentr√©e API
________________________________________
86.Le CQRS (Command Query Responsibility Segregation) :
A. S√©pare les mod√®les de lecture et d‚Äô√©criture
B. N√©cessite deux bases de donn√©es distinctes
C. Am√©liore la scalabilit√© et la clart√© des intentions (read/write)
D. Est obligatoire pour tout projet EF Core
E. Peut coexister avec Mediator / MediatR
________________________________________
87.Dans une impl√©mentation CQRS avec MediatR :
A. Chaque Command ou Query est un objet envoy√© √† un Handler
B. Le Handler retourne toujours IActionResult
C. Les Commands modifient l‚Äô√©tat, les Queries ne doivent avoir aucun effet de bord
D. Plusieurs handlers peuvent traiter une m√™me commande simultan√©ment
E. Le Mediator centralise les appels pour d√©coupler les d√©pendances directes
________________________________________
88.Pourquoi ne pas exposer les entit√©s EF Core directement via l‚ÄôAPI ?
A. Cela simplifie la maintenance
B. Fuite de la structure interne de la base (casse les clients √† chaque √©volution)
C. Risque de r√©f√©rence circulaire et s√©rialisation infinie
D. Violation du principe de s√©paration entre mod√®le m√©tier et contrat d‚Äôexposition (DTO)
E. Les entit√©s ne sont pas s√©rialisables
________________________________________
89.Le mapping entit√© ‚Üî DTO :
A. Doit toujours √™tre manuel
B. Peut √™tre automatis√© par des frameworks (Mapperly, AutoMapper)
C. Peut √™tre g√©n√©r√© compile-time (Mapperly) pour √©viter le co√ªt de r√©flexion
D. Peut inclure une logique de transformation (ex : concat√©ner Nom + Pr√©nom)
E. Est inutile si les entit√©s correspondent 1:1 √† la base
________________________________________
90.Concernant la coh√©rence transactionnelle entre Command et Query :
A. Une Command doit √™tre transactionnelle (atomicit√© garantie)
B. Une Query peut ouvrir une transaction pour lecture isol√©e
C. On √©vite que les Query et Command partagent le m√™me DbContext
D. Les Handlers Command peuvent injecter un IUnitOfWork pour contr√¥ler la persistance
E. Les transactions doivent √™tre g√©r√©es dans les contr√¥leurs
________________________________________

