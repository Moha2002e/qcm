[
  {
    "id": 87,
    "question": "Lorsqu’une entité est lue via un DbContext, puis modifiée sans appel à Attach ou Update, EF Core :",
    "options": [
      "Lève une exception de suivi incohérent",
      "Ignore la modification",
      "La détecte automatiquement si elle est suivie par le ChangeTracker",
      "Modifie toutes les lignes correspondantes",
      "Nécessite explicitement context.Entry(entity).State = Modified"
    ],
    "correctAnswer": 0
  },
  {
    "id": 88,
    "question": "Le comportement de context.Attach(entity) dépend de :",
    "options": [
      "Si la clé primaire est renseignée ou non",
      "L’état courant de l’entité",
      "Les entités enfants rattachées",
      "Le mode de suivi du contexte",
      "Toutes ces réponses"
    ],
    "correctAnswer": 0
  },
  {
    "id": 89,
    "question": "Lors d’un SaveChanges(), EF Core :",
    "options": [
      "Génère un script SQL et l’exécute sans transaction",
      "Utilise une transaction implicite regroupant les modifications suivies",
      "Valide chaque entité individuellement",
      "Envoie un batch par propriété modifiée",
      "Dépend du provider de base de données uniquement"
    ],
    "correctAnswer": 0
  },
  {
    "id": 90,
    "question": "Si deux DbContext différents chargent la même entité et que chacun la modifie avant SaveChanges(), EF :",
    "options": [
      "Écrase silencieusement le dernier enregistrement",
      "Lance une exception d’accès concurrent",
      "Ne détecte pas le conflit sauf si une colonne de concurrence est configurée",
      "Synchronise automatiquement les changements",
      "Fusionne les versions"
    ],
    "correctAnswer": 0
  },
  {
    "id": 91,
    "question": "Quelle est la différence entre Add() et Attach() ?",
    "options": [
      "Attach crée une nouvelle entité, Add la réutilise",
      "Add attache mais ne change pas l’état",
      "Add marque l’entité comme Added, Attach comme Unchanged",
      "Elles sont équivalentes",
      "Attach ne fonctionne que sur les entités enfants"
    ],
    "correctAnswer": 0
  },
  {
    "id": 92,
    "question": "Un DbContext ne doit généralement pas être enregistré en Singleton car :",
    "options": [
      "Il ne gère pas le multithreading",
      "Il ne supporte pas les transactions longues",
      "Son ChangeTracker accumule les entités",
      "Il est conçu pour une durée de vie courte (Scoped)",
      "Toutes ces réponses"
    ],
    "correctAnswer": 0
  },
  {
    "id": 93,
    "question": "Quelle instruction crée réellement la table en base dans une approche Code-First ?",
    "options": [
      "EnsureCreated()",
      "Add-Migration",
      "Update-Database",
      "Migrate()",
      "context.SaveChanges()"
    ],
    "correctAnswer": 0
  },
  {
    "id": 94,
    "question": "Les conventions par défaut d’EF Core :",
    "options": [
      "Imposent les noms de colonnes en majuscules",
      "Ne peuvent pas être surchargées",
      "Peuvent être remplacées via Fluent API ou annotations",
      "Sont désactivées par défaut",
      "N’agissent que sur les clés étrangères"
    ],
    "correctAnswer": 0
  },
  {
    "id": 95,
    "question": "Lorsqu’un DbContext suit deux entités ayant la même clé primaire :",
    "options": [
      "EF met à jour la plus récente",
      "EF crée deux lignes",
      "Une exception InvalidOperationException est levée",
      "Les deux sont fusionnées",
      "Rien ne se passe"
    ],
    "correctAnswer": 0
  },
  {
    "id": 96,
    "question": "Le ChangeTracker.AutoDetectChangesEnabled désactivé permet :",
    "options": [
      "D’empêcher la détection de modifications automatiques",
      "D’optimiser les opérations massives (batch)",
      "De désactiver la persistance",
      "De supprimer le contexte",
      "De rendre SaveChanges() instantané"
    ],
    "correctAnswer": 0
  },
  {
    "id": 97,
    "question": "La suppression en cascade implicite s’applique :",
    "options": [
      "À toutes les relations",
      "Seulement si la relation est Required (non nullable)",
      "Seulement si DeleteBehavior.Cascade est explicite",
      "Jamais, par sécurité",
      "Pour toutes les entités enfants"
    ],
    "correctAnswer": 0
  },
  {
    "id": 98,
    "question": "Quelle est la sortie SQL la plus probable du code suivant : context.Students.Where(s => s.Grade.GradeName == \"A\");",
    "options": [
      "Un JOIN avec la table Grade",
      "Une sous-requête",
      "Une requête cartésienne",
      "Un SELECT sur Students uniquement",
      "Une exception de mapping"
    ],
    "correctAnswer": 0
  },
  {
    "id": 99,
    "question": "Dans un modèle Many-to-Many sans entité de jointure explicite, EF Core :",
    "options": [
      "Crée une entité Join implicite",
      "Crée une table de liaison sans classe dédiée",
      "Requiert [ForeignKey] manuelle",
      "Nécessite une configuration One-to-Many double",
      "Ne supporte pas ce scénario"
    ],
    "correctAnswer": 0
  },
  {
    "id": 100,
    "question": "Quelle est la conséquence de context.ChangeTracker.Clear() ?",
    "options": [
      "Supprime la base",
      "Détache toutes les entités suivies",
      "Vide les tables",
      "Enregistre les changements",
      "Met les entités à Unchanged"
    ],
    "correctAnswer": 0
  },
  {
    "id": 101,
    "question": "Une migration EF Core contient :",
    "options": [
      "Un snapshot du modèle + le code SQL des modifications",
      "Des métadonnées JSON",
      "Deux classes : une Migration et un ModelSnapshot",
      "Des scripts SQL exécutables",
      "Des triggers automatiques"
    ],
    "correctAnswer": 0
  },
  {
    "id": 102,
    "question": "Si Database.EnsureCreated() est utilisé avant une migration :",
    "options": [
      "La migration suivante l’écrase",
      "Les migrations ne pourront plus être appliquées sans supprimer la DB",
      "Les migrations s’empilent",
      "EF fusionne les deux schémas",
      "Rien ne change"
    ],
    "correctAnswer": 0
  },
  {
    "id": 103,
    "question": "Le code : context.Entry(student).State = EntityState.Detached;",
    "options": [
      "Sauvegarde l’entité",
      "Détache l’entité du contexte, elle n’est plus suivie",
      "Supprime la ligne en DB",
      "Rattache une entité",
      "Fait un rollback"
    ],
    "correctAnswer": 0
  },
  {
    "id": 104,
    "question": "LINQ to Entities :",
    "options": [
      "Utilise des itérateurs C#",
      "Exécute la requête côté client",
      "Traduit l’expression en SQL exécuté côté serveur",
      "Crée un cache mémoire",
      "Est identique à LINQ to Objects"
    ],
    "correctAnswer": 0
  },
  {
    "id": 105,
    "question": "FirstOrDefault() sur un IQueryable EF Core :",
    "options": [
      "Charge tout le dataset",
      "Exécute immédiatement la requête SQL avec TOP 1",
      "Retourne un proxy non chargé",
      "Retourne null si rien n’est trouvé",
      "Crée une collection vide si rien n’est trouvé"
    ],
    "correctAnswer": 0
  },
  {
    "id": 106,
    "question": "La commande dotnet ef migrations add Init --context AppContext :",
    "options": [
      "Ajoute une migration en précisant la classe de contexte",
      "Crée la base",
      "Liste les migrations",
      "Ajoute une première migration",
      "Applique la migration"
    ],
    "correctAnswer": 0
  },
  {
    "id": 107,
    "question": "Quelle différence principale existe entre AsEnumerable() et AsNoTracking() sur une requête EF Core ?",
    "options": [
      "AsEnumerable() exécute la requête en mémoire",
      "AsNoTracking() désactive la détection des modifications",
      "AsEnumerable() conserve le tracking",
      "AsNoTracking() est plus léger pour la lecture seule",
      "Toutes ces réponses sont correctes"
    ],
    "correctAnswer": 0
  },
  {
    "id": 108,
    "question": "Le code suivant : var s = context.Students.First(); s.Name = \"Karl\"; context.SaveChanges(); Que fait EF Core ?",
    "options": [
      "N’enregistre pas le changement sans Update()",
      "Détecte la modification et exécute un UPDATE SQL",
      "Crée un nouvel enregistrement",
      "Déclenche une exception si la table est vide",
      "Met la ligne à Unchanged"
    ],
    "correctAnswer": 0
  },
  {
    "id": 109,
    "question": "Lorsqu’une propriété Navigation est marquée virtual, EF Core :",
    "options": [
      "Crée un proxy dynamique pour le lazy loading",
      "Peut différer le chargement des données liées",
      "Nécessite Microsoft.EntityFrameworkCore.Proxies",
      "Désactive le tracking",
      "Ne supporte pas le Include()"
    ],
    "correctAnswer": 0
  },
  {
    "id": 110,
    "question": "L’option UseQueryTrackingBehavior(QueryTrackingBehavior.NoTracking) configurée globalement :",
    "options": [
      "Désactive les transactions",
      "Désactive par défaut le suivi des entités retournées",
      "Rend la lecture plus performante",
      "Bloque SaveChanges()",
      "Nécessite un rechargement manuel pour modifier"
    ],
    "correctAnswer": 0
  },
  {
    "id": 111,
    "question": "Quel est le résultat de ce code ? context.Students.Where(s => s.Id == 1).FirstOrDefault(); context.Students.Where(s => s.Id == 1).FirstOrDefault();",
    "options": [
      "Une seule requête SQL est exécutée grâce au cache EF",
      "Deux requêtes SQL sont exécutées, pas de cache de requête par défaut",
      "La seconde lève une exception de suivi",
      "Une transaction est ouverte",
      "Le premier résultat reste en mémoire partagée"
    ],
    "correctAnswer": 0
  },
  {
    "id": 112,
    "question": "Les Shadow Properties dans EF Core :",
    "options": [
      "Sont des propriétés non déclarées dans la classe C# mais suivies par EF",
      "Permettent de stocker des métadonnées internes (FK, timestamps, etc.)",
      "Ne sont accessibles que via Entry().Property(\"Nom\")",
      "Peuvent être persistées en base",
      "Toutes ces réponses"
    ],
    "correctAnswer": 0
  },
  {
    "id": 113,
    "question": "Le type de suppression DeleteBehavior.ClientSetNull :",
    "options": [
      "Supprime les enfants en base",
      "Met à null les FK en mémoire, sans propager en DB avant SaveChanges()",
      "Dépend de la transaction",
      "Supprime aussi le parent",
      "Déconnecte le contexte"
    ],
    "correctAnswer": 0
  },
  {
    "id": 114,
    "question": "Les Owned Types :",
    "options": [
      "Sont stockés dans la même table que l’entité propriétaire",
      "Représentent des objets de valeur sans clé propre",
      "Ne peuvent être partagés entre entités",
      "Nécessitent Fluent API",
      "Toutes ces réponses"
    ],
    "correctAnswer": 0
  },
  {
    "id": 115,
    "question": "Pour qu’une propriété DateCreated soit automatiquement remplie lors de l’insertion :",
    "options": [
      "[DatabaseGenerated(DatabaseGeneratedOption.Computed)]",
      "[DefaultValue(\"getdate()\")]",
      "Configuration via Fluent API .HasDefaultValueSql(\"getutcdate()\")",
      "[Timestamp]",
      "Nécessite un trigger SQL"
    ],
    "correctAnswer": 0
  },
  {
    "id": 116,
    "question": "Les requêtes composées sur IQueryable EF Core sont :",
    "options": [
      "Exécutées immédiatement",
      "Construites en expression tree et traduites à l’exécution (deferred execution)",
      "Stockées en cache jusqu’à ToList()",
      "Exécutées ligne par ligne",
      "Converties en LINQ to Objects"
    ],
    "correctAnswer": 0
  },
  {
    "id": 117,
    "question": "Le code suivant : var stud = new Student { Id = 10, Name = \"Karl\" }; context.Update(stud); Suppose que l’étudiant existe déjà.",
    "options": [
      "Marque l’entité comme Modified sans la lire",
      "Charge la ligne depuis la base",
      "Lève une exception s’il n’existe pas",
      "Supprime les relations",
      "Nécessite un SaveChanges() pour exécuter le SQL"
    ],
    "correctAnswer": 0
  },
  {
    "id": 118,
    "question": "Quelle pratique est déconseillée pour les performances EF ?",
    "options": [
      "Include() sur plusieurs niveaux de profondeur",
      "ToList() avant Where()",
      "Charger 10 000 entités trackées",
      "Exécuter SaveChanges() dans une boucle",
      "Toutes ces pratiques sont déconseillées"
    ],
    "correctAnswer": 0
  },
  {
    "id": 119,
    "question": "Les clés composites sont configurées via :",
    "options": [
      "[Key(\"A\",\"B\")]",
      "[CompositeKey]",
      "modelBuilder.Entity<T>().HasKey(e => new { e.A, e.B })",
      "AddCompositeKey()",
      "Non supporté par EF"
    ],
    "correctAnswer": 0
  },
  {
    "id": 120,
    "question": "Le mode SingleOrDefault() :",
    "options": [
      "Lève une exception si plus d’une correspondance existe",
      "Retourne null si aucune entité",
      "Peut charger plus lentement qu’un FirstOrDefault()",
      "Combine filtrage + validation d’unicité",
      "Ne peut pas être traduit en SQL"
    ],
    "correctAnswer": 0
  },
  {
    "id": 121,
    "question": "Les Compiled Queries d’EF Core servent à :",
    "options": [
      "Exécuter du SQL brut",
      "Précompiler l’arbre d’expression pour réutilisation (gain de perf)",
      "Créer des index",
      "Générer des migrations automatiques",
      "Sauvegarder le contexte"
    ],
    "correctAnswer": 0
  },
  {
    "id": 122,
    "question": "Quel scénario nécessite le TransactionScope ?",
    "options": [
      "SaveChanges() standard",
      "Modification de plusieurs contextes ou sources de données dans la même transaction",
      "Lazy Loading",
      "Delete cascade",
      "Mapping complexe"
    ],
    "correctAnswer": 0
  },
  {
    "id": 123,
    "question": "L’option .UseLazyLoadingProxies() :",
    "options": [
      "Est activée par défaut",
      "Nécessite les propriétés virtual",
      "Crée des proxys dynamiques pour charger les données à la demande",
      "Affecte les performances",
      "Réponses : B, C, D"
    ],
    "correctAnswer": 0
  },
  {
    "id": 124,
    "question": "Quelle différence entre Find() et FirstOrDefault() ?",
    "options": [
      "Find() cherche d’abord dans le cache du contexte avant la DB",
      "Find() nécessite la clé primaire",
      "FirstOrDefault() exécute toujours une requête SQL",
      "Find() est plus rapide si l’entité est déjà suivie",
      "Toutes ces réponses"
    ],
    "correctAnswer": 0
  },
  {
    "id": 125,
    "question": "Une migration contenant un renommage de colonne et un changement de type :",
    "options": [
      "Est exécutée en une seule commande SQL",
      "Peut générer un DROP + CREATE selon le provider",
      "Ne peut pas être rollbackée",
      "N’est pas détectée automatiquement",
      "Supprime la contrainte FK associée"
    ],
    "correctAnswer": 0
  },
  {
    "id": 126,
    "question": "Pour insérer des données initiales conditionnelles :",
    "options": [
      "[SeedData]",
      "Utiliser HasData() dans OnModelCreating",
      "Créer une classe statique DbSeeder exécutée au démarrage",
      "Ajouter une migration spéciale",
      "Utiliser context.Database.Migrate()"
    ],
    "correctAnswer": 0
  },
  {
    "id": 127,
    "question": "Différence principale Middleware vs Filter en Web API :",
    "options": [
      "Les filters s’exécutent avant le routing",
      "Les middlewares enveloppent tout le pipeline, les filters ciblent contrôleurs/actions",
      "Les filters ont accès au ModelState et aux résultats d’action",
      "Les middlewares ne peuvent pas court-circuiter la réponse",
      "Les middlewares peuvent s’appliquer aux fichiers statiques et endpoints non-API"
    ],
    "correctAnswer": 0
  },
  {
    "id": 128,
    "question": "En Minimal APIs, que renvoie le plus précisément Results.NotFound() ?",
    "options": [
      "ActionResult",
      "IActionResult",
      "Un IResult (implémentation HttpResults)",
      "ProblemDetails",
      "HttpResponseMessage"
    ],
    "correctAnswer": 0
  },
  {
    "id": 129,
    "question": "Pour masquer la validation implicite d’[ApiController] et gérer toi-même la réponse :",
    "options": [
      "Supprimer [ApiController]",
      "Désactiver SuppressModelStateInvalidFilter",
      "Utiliser [ValidateNever] sur le type",
      "Intercepter via un ActionFilter et tester ModelState.IsValid",
      "app.Services.DisableValidation()"
    ],
    "correctAnswer": 0
  },
  {
    "id": 130,
    "question": "Concernant ActionResult<T> :",
    "options": [
      "Empêche de retourner NotFound()",
      "Permet de retourner soit un T, soit un IActionResult",
      "Sérialise T et force 200 OK",
      "Expose le type pour la doc OpenAPI plus précisément qu’un IActionResult",
      "N’est pas compatible avec async"
    ],
    "correctAnswer": 0
  },
  {
    "id": 131,
    "question": "[FromBody] vs [FromQuery] : comportement par défaut en API :",
    "options": [
      "Les paramètres simples viennent du body par défaut",
      "Un seul paramètre [FromBody] par action en JSON (par défaut)",
      "Les paramètres complexes (classe) viennent du body par défaut",
      "Les paramètres simples (string, int) viennent du body",
      "Les paramètres simples viennent de la query/route par défaut"
    ],
    "correctAnswer": 0
  },
  {
    "id": 132,
    "question": "ILogger<T> : lequel est vrai ?",
    "options": [
      "Les messages interpolés sont toujours structurés",
      "Utiliser des “message templates” logger.LogInformation(\"User {Id} ...\", id) crée des champs structurés",
      "Écrire des objets comme {@obj} n’est supporté que par STJ",
      "ILogger nécessite Serilog",
      "Le nom de catégorie du log “category name” est le nom de T par défaut"
    ],
    "correctAnswer": 0
  },
  {
    "id": 133,
    "question": "Serilog avec ASP.NET Core pour journaliser chaque requête :",
    "options": [
      "Ajouter UseLogging()",
      "app.UseSerilogRequestLogging()",
      "Logger uniquement en Production",
      "Possibilité d’enrichir (ex: WithMachineName, FromLogContext) via config",
      "Oblige le format JSON"
    ],
    "correctAnswer": 0
  },
  {
    "id": 134,
    "question": "Configurer Swagger/Scalar en .NET 9 :",
    "options": [
      "builder.Services.AddOpenApi()",
      "app.UseSwagger() obligatoire",
      "app.MapOpenApi() pour exposer /openapi/v1.json",
      "app.MapScalarApiReference() pour l’UI Scalar",
      "app.UseOpenApiUI()"
    ],
    "correctAnswer": 0
  },
  {
    "id": 135,
    "question": "CancellationToken dans une action :",
    "options": [
      "Peut être passé en paramètre pour annuler un await db.ToListAsync(ct)",
      "Inutile pour EF Core",
      "Désactive le time-out",
      "Est alimenté par la fermeture de la connexion HTTP",
      "N’est disponible qu’en Minimal API"
    ],
    "correctAnswer": 0
  },
  {
    "id": 136,
    "question": "Choisir la durée de vie DI appropriée :",
    "options": [
      "DbContext en Singleton pour réduire les allocations",
      "HttpClient en Scoped par défaut",
      "DbContext en Scoped (requête)",
      "Services stateless (Mapper, Validator) souvent en Transient",
      "Caches/configuration (lecture) en Singleton"
    ],
    "correctAnswer": 0
  },
  {
    "id": 137,
    "question": "Pour valider un modèle d’entrée (DTO) avec des règles avancées :",
    "options": [
      "[RegularExpression] uniquement",
      "FluentValidation (librairie tierce) ou DataAnnotations",
      "Créer un ActionFilter de validation pour format unifié des erreurs",
      "Valider le DTO dans le contrôleur",
      "ModelState est obsolète"
    ],
    "correctAnswer": 0
  },
  {
    "id": 138,
    "question": "Pagination propre en Web API :",
    "options": [
      "Prendre tout puis paginer en mémoire",
      "Retourner des métadonnées (page, size, total) dans des en-têtes ou un enveloppe JSON",
      "Limiter pageSize max côté serveur",
      "Utiliser AsNoTracking pour les listes",
      "Ignorer la stabilité d’ordre"
    ],
    "correctAnswer": 0
  },
  {
    "id": 139,
    "question": "Minimal APIs vs Controllers :",
    "options": [
      "Minimal = pas de filtres possible",
      "Minimal expose des endpoints fonctionnels, léger pour microservices",
      "Controllers = filtres + conventions MVC + attributs riches",
      "Minimal interdit DI",
      "Minimal renvoie des IResult, contrôleur renvoie ActionResult<T>"
    ],
    "correctAnswer": 0
  },
  {
    "id": 140,
    "question": "Global exception handling recommandé :",
    "options": [
      "try/catch dans chaque action",
      "Middleware global + mapping → ProblemDetails standard",
      "Filtres d’exception uniquement",
      "Rediriger vers /error en production",
      "Journaliser (corrélation Id) + ne pas divulguer les détails en prod"
    ],
    "correctAnswer": 0
  },
  {
    "id": 141,
    "question": "Routing : contraintes et noms :",
    "options": [
      "[HttpGet(\"{id:int}\")] contraint id à un entier",
      "Le nom d’une route (ex. :GetByName) doit être unique quel que soit le contrôleur",
      "Les routes nommées ne servent qu’à la doc",
      "Des paramètres optionnels \"{category?}\" sont possibles",
      "* capture un segment, ** plusieurs (catch-all)"
    ],
    "correctAnswer": 0
  },
  {
    "id": 142,
    "question": "Content negotiation :",
    "options": [
      "Par défaut JSON via System.Text.Json",
      "Accept: application/xml est toujours respecté sans config",
      "On peut ajouter un formatter XML",
      "text/csv est pris en charge nativement",
      "La négociation peut renvoyer 406 si non supporté (si configuré)"
    ],
    "correctAnswer": 0
  },
  {
    "id": 143,
    "question": "OpenAPI doc :",
    "options": [
      "Toujours exposer /openapi/v1.json en prod sans auth",
      "Protéger l’UI (Swagger/Scalar) en prod ou la désactiver",
      "Décrire les schémas, codes de retour, auth (OAuth2/Bearer)",
      "Générer automatiquement des clients sans configuration",
      "MapOpenApi() supporte plusieurs versions"
    ],
    "correctAnswer": 0
  },
  {
    "id": 144,
    "question": "Performance — anti-patterns courants :",
    "options": [
      "Serializer synchro sur gros payloads",
      "ToList() prématuré avant Where/Select",
      "Logging verbeux au niveau Debug/Trace en prod",
      "AsNoTracking() pour lecture seule",
      "SaveChanges() dans une boucle au lieu de batch"
    ],
    "correctAnswer": 0
  },
  {
    "id": 145,
    "question": "HttpLoggingMiddleware :",
    "options": [
      "Peut journaliser headers, requête, réponse",
      "Toujours recommandé en prod sans filtre",
      "Risque de fuite de données sensibles si mal configuré",
      "Ne fonctionne pas avec HTTPS",
      "Peut dégrader la perf si on logge les bodies volumineux"
    ],
    "correctAnswer": 0
  },
  {
    "id": 146,
    "question": "DI circular dependency :",
    "options": [
      "Peut provoquer des boucles d’initialisation et exceptions",
      "Résolu automatiquement par le conteneur",
      "Souvent signe d’un design à refactorer",
      "Résolu en changeant toutes les durées de vie en Singleton",
      "Parfois corrigé en introduisant des ports/interfaces plus fins"
    ],
    "correctAnswer": 0
  },
  {
    "id": 147,
    "question": "JSON patch / partial updates :",
    "options": [
      "HttpPatch non supporté",
      "Supporté uniquement via Newtonsoft",
      "Valider les opérations patch et la sécurité (chemins autorisés)",
      "Toujours préférable à PUT",
      "Penser à la concurrence (RowVersion)"
    ],
    "correctAnswer": 0
  },
  {
    "id": 148,
    "question": "La Clean Architecture vise avant tout à :",
    "options": [
      "Réduire le couplage entre UI et données",
      "Faire dépendre le code métier uniquement d’abstractions",
      "Isoler le domaine de toute technologie (framework, base, UI)",
      "Utiliser CQRS obligatoirement",
      "Faciliter le test unitaire et la maintenabilité dans le temps"
    ],
    "correctAnswer": 0
  },
  {
    "id": 149,
    "question": "Dans une architecture en couches proprement isolée :",
    "options": [
      "La couche Presentation référence la couche Domain directement",
      "La couche Application référence le Domain et expose des interfaces implémentées dans Infrastructure",
      "Infrastructure connaît Application mais pas l’inverse",
      "Les dépendances vont toujours du haut (UI) vers le bas (Domain)",
      "Les DTO peuvent être définis dans Domain"
    ],
    "correctAnswer": 0
  },
  {
    "id": 150,
    "question": "Le pattern Repository permet :",
    "options": [
      "De remplacer les requêtes SQL par LINQ",
      "D’avoir un accès direct au contexte EF",
      "D’encapsuler la logique d’accès aux données derrière une interface abstraite",
      "De rendre les tests possibles avec des mocks ou bases InMemory",
      "D’utiliser EF Core"
    ],
    "correctAnswer": 0
  },
  {
    "id": 151,
    "question": "Quel est le rôle d’un Service d’application dans la Clean Architecture ?",
    "options": [
      "Orchestrer les règles métier entre plusieurs entités et repositories",
      "Remplacer le contrôleur",
      "Coordonner le mapping entité ↔ DTO et déclencher des transactions",
      "Implémenter la logique de validation HTTP",
      "Exécuter directement les requêtes SQL"
    ],
    "correctAnswer": 0
  },
  {
    "id": 152,
    "question": "Le Domain Layer devrait contenir :",
    "options": [
      "Des entités, des value objects, et les règles métier pures",
      "Les classes de configuration EF",
      "Les contrôleurs",
      "Aucune dépendance vers Entity Framework ou ASP.NET Core",
      "Les DTO d’entrée API"
    ],
    "correctAnswer": 0
  },
  {
    "id": 153,
    "question": "Le CQRS (Command Query Responsibility Segregation) :",
    "options": [
      "Sépare les modèles de lecture et d’écriture",
      "Nécessite deux bases de données distinctes",
      "Améliore la scalabilité et la clarté des intentions (read/write)",
      "Est obligatoire pour tout projet EF Core",
      "Peut coexister avec Mediator / MediatR"
    ],
    "correctAnswer": 0
  },
  {
    "id": 154,
    "question": "Dans une implémentation CQRS avec MediatR :",
    "options": [
      "Chaque Command ou Query est un objet envoyé à un Handler",
      "Le Handler retourne toujours IActionResult",
      "Les Commands modifient l’état, les Queries ne doivent avoir aucun effet de bord",
      "Plusieurs handlers peuvent traiter une même commande simultanément",
      "Le Mediator centralise les appels pour découpler les dépendances directes"
    ],
    "correctAnswer": 0
  },
  {
    "id": 155,
    "question": "Pourquoi ne pas exposer les entités EF Core directement via l’API ?",
    "options": [
      "Cela simplifie la maintenance",
      "Fuite de la structure interne de la base (casse les clients à chaque évolution)",
      "Risque de référence circulaire et sérialisation infinie",
      "Violation du principe de séparation entre modèle métier et contrat d’exposition (DTO)",
      "Les entités ne sont pas sérialisables"
    ],
    "correctAnswer": 0
  },
  {
    "id": 156,
    "question": "Le mapping entité ↔ DTO :",
    "options": [
      "Doit toujours être manuel",
      "Peut être automatisé par des frameworks (Mapperly, AutoMapper)",
      "Peut être généré compile-time (Mapperly) pour éviter le coût de réflexion",
      "Peut inclure une logique de transformation (ex : concaténer Nom + Prénom)",
      "Est inutile si les entités correspondent 1:1 à la base"
    ],
    "correctAnswer": 0
  },
  {
    "id": 157,
    "question": "Concernant la cohérence transactionnelle entre Command et Query :",
    "options": [
      "Une Command doit être transactionnelle (atomicité garantie)",
      "Une Query peut ouvrir une transaction pour lecture isolée",
      "On évite que les Query et Command partagent le même DbContext",
      "Les Handlers Command peuvent injecter un IUnitOfWork pour contrôler la persistance",
      "Les transactions doivent être gérées dans les contrôleurs"
    ],
    "correctAnswer": 0
  }
]